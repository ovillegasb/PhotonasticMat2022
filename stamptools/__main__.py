#!/bin/env python
# -*- coding: utf-8 -*-

"""Using stamptools directly in terminal."""

import argparse
import os
from stamptools.stamp import STAMP
from stamptools.analysis import traj_analysis, rdf_analysis
from stamptools.analysis import get_distances_from
from stamptools.analysis import gen_centered_traj, mol_traj_analysis
from stamptools.analysis import traj_analysis_agg
from stamptools.analysis import mol_traj_cut_distance, get_angles_distance
from stamptools.analysis import get_dist_from_closest_atom
from stamptools.analysis import get_acorr_function_angle
from stamptools.fatomes import TOPOL
from stamptools.stamptools import clean_data, read_geometry_file
import pandas as pd


TITLE = """\033[1;36m
   _____ _______       __  __ _____ _______ ____   ____  _       _____ 
  / ____|__   __|/\\   |  \\/  |  __ \\__   __/ __ \\ / __ \\| |     / ____|
 | (___    | |  /  \\  | \\  / | |__) | | | | |  | | |  | | |    | (___  
  \\___ \\   | | / /\\ \\ | |\\/| |  ___/  | | | |  | | |  | | |     \\___ \\ 
  ____) |  | |/ ____ \\| |  | | |      | | | |__| | |__| | |____ ____) |
 |_____/   |_/_/    \\_\\_|  |_|_|      |_|  \\____/ \\____/|______|_____/ 
\033[m
Module created to study systems generated by STAMP.

Author: Orlando VILLEGAS
Date: 2022-09-08
Stamp: v4.220721

Description:

    Suite of tools for working with Stamp4 output and input files.

Usage:

    Save the trajectory of a molecule in xyz (mol_traj_0.xyz):
        python -m stamptools -d DONNEES.in --mol_traj 0 --traj_type [XYZ default or GRO, XTC]

    Saving information about the size and shape of molecules (molprop.csv):
        python -m stamptools -d DONNEES.in --molprop --traj_type [XYZ default or GRO, XTC]

    Molecules around from a distance cut
        python -m stamptools -l --mol_d_aa -mref 0 --out_folder distances --rcutoff 0.5

    On server:
        python -um stamptools [OPTIONS] > log &

    Combined analysis:
        python -m stamptools -l --centered_traj --rcutoff 1.0 -mref 0 --out_folder test0 --centerm

    Angles distances:
        python -m stamptools -l --centerm --ref_plane -mref 0 -atref 11 12 13

    Aggregate analysis:
        python -m stamptools -d DONNEES.in --aggregate 0:19 --traj_type GRO -b 0.0 -e 100.

"""


def options():
    """Generate command line interface."""
    parser = argparse.ArgumentParser(
        prog="stamptools",
        usage="%(prog)s [-options]",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="Enjoy the program!"
    )

    fileinput = parser.add_argument_group(
        "\033[1;36mInitial settings\033[m")

    fileinput.add_argument(
        "-d", "--donnees",
        help="Specifies the system DONNEES file.",
        default=None
    )

    fileinput.add_argument(
        "-f", "--fatomes",
        help="Specifies the FAtomes file.",
        default=None
    )

    fileinput.add_argument(
        "--dataStamp",
        help="Specify data file, default is Stamp.dat.",
        default="Stamp.dat"
    )

    fileinput.add_argument(
        "--traj_type",
        help="Type of trajectory to work, XYZ, GRO and XTC can be used.",
        default="XYZ"
    )

    fileinput.add_argument(
        "--geom_file",
        help="Input file with the geometry of the molecule.",
        default=None
    )

    analysis = parser.add_argument_group(
        "\033[1;36mAnalysis options\033[m")

    analysis.add_argument(
        "--mol_traj",
        help="Analyze trajectory of a particular molecule, use resid.",
        type=int,
        default=None
    )

    analysis.add_argument(
        "--molprop",
        help="Analyze the shape and size of the molecules present.",
        action="store_true"
    )

    analysis.add_argument(
        "--aggregate",
        help="Analyze the shape and size from a aggregate present, define mol\
selection, start from resid 0. Examples:\
\"[0 1 2 3 4 8\" \"0:20\" \"0 to 20\"",
        nargs="+",
        default=None
    )

    analysis.add_argument(
        "--autocorrelation",
        help="Performs an autocorrelation analysis, generates an acf.csv file\
for a chosen property.",
        action="store_true"
    )

    analysis.add_argument(
        "-mref", "--mref",
        help="Reference molecule.",
        type=int,
        default=None
    )

    analysis.add_argument(
        "-b", "--b",
        help="Time of first frame to read from trajectory (default unit ps).",
        type=float,
        default=0.0
    )

    analysis.add_argument(
        "-e", "--e",
        help="Time of last frame to read from trajectory (default unit ps).",
        type=float,
        default=None
    )

    analysis.add_argument(
        "-i", "--interval",
        help="Interval time (default unit ps).",
        type=int,
        default=1
    )

    analysis.add_argument(
        "-t0", "--t0",
        help="Define an initial time for data processing (default unit ps).",
        type=float,
        default=0.0
    )

    analysis.add_argument(
        "-freq", "--freq",
        help="Defines a frame time frequency for data processing. (default unit ps).",
        type=float,
        default=1.0
    )

    analysis.add_argument(
        "--NUMPROC",
        help="Number of processors to be used.",
        type=int,
        default=12
    )

    analysis.add_argument(
        "-angle", "--angle",
        help="Select an angle defined in the geometry file.",
        type=str,
        default=None
    )

    analysis.add_argument(
        "-atref", "--atref",
        help="References atoms.",
        type=int,
        nargs="+",
        default=None
    )

    analysis.add_argument(
        "--centered_traj",
        help="Generates a trajectory using a reference molecule.",
        action="store_true"
    )

    analysis.add_argument(
        "--rcutoff",
        help="Cut-off distance with respect to the reference molecule.",
        type=float,
        default=1.0
    )

    analysis.add_argument(
        "--out_folder",
        help="Name of the output directory.",
        type=str,
        default="centered_traj"
    )

    analysis.add_argument(
        "--mol_d_aa",
        help="Extract the structure of mol around a reference mol using atom-a\
tom distance.",
        action="store_true"
    )

    analysis.add_argument(
        "--mol_d",
        help="Analyze center of mass distance from a referece, use resid.",
        action="store_true"
    )

    analysis.add_argument(
        "--reset",
        help="Re-collect data.",
        action="store_true"
    )

    analysis.add_argument(
        "--ref_plane",
        help="The angle between the normal vector to a plane formed by three a\
toms centered at the center of mass of the reference molecule and the center o\
f mass is analyzed.",
        action="store_true"
    )

    analysis.add_argument(
        "-rdf", "--rdf",
        help="Calculate the rdf of a reference molecule and the surrounding mo\
lecules. Three types can be specified. all, cm or 12-13 (atomic index)."
    )

    analysis.add_argument(
        "--closestDist",
        help="Calculates the closest distance between atoms and saves it in a \
csv file.",
        action="store_true"
    )

    sysStructure = parser.add_argument_group(
        "\033[1;36mStructural modification options\033[m")

    sysStructure.add_argument(
        "--add_hydrogen",
        help="Reads a fatome and adds missing hydrogens to terminal carbon atoms.",
        action="store_true"
    )

    sysStructure.add_argument(
        "--add_OH",
        help="Reads a fatome and adds an OH group to vacant terminal carbons.",
        action="store_true"
    )

    sysStructure.add_argument(
        "--noPBC",
        help="Reads the FAtome or a frame and returns a coordinate file without PBC.",
        action="store_true"
    )

    gromacs = parser.add_argument_group(
        "\033[1;36mAnalysis GROMACS options\033[m")

    gromacs.add_argument(
        "--top",
        help="System topology, gro file.",
        type=str,
        default="./XTC/confout.gro"
    )

    gromacs.add_argument(
        "--xtc",
        help="System trajectory, xtc file.",
        type=str,
        default="./XTC/traj_comp.xtc"
    )

    fileout = parser.add_argument_group(
        "\033[1;36mOutput settings\033[m")

    fileout.add_argument(
        "--format",
        help="Specifies the out format.",
        default="xyz",
        type=str
    )

    return vars(parser.parse_args())


def read_traj(system, **kwargs):
    """Read the trajectory for specific limits in time (ps)."""    
    time_per_frame = system.time_per_frame
    interval = kwargs["interval"]
    if kwargs["b"] > 0.0:
        b = time_per_frame[time_per_frame["time"] >= kwargs["b"]].index[0]
        b = int(b)
    else:
        b = list(time_per_frame.index)[0]
    if kwargs["e"] is not None:
        e = list(time_per_frame[time_per_frame["time"] <= kwargs["e"]].index)[-1]
        e = int(e)
    else:
        e = list(time_per_frame.index)[-1]

    print("Time init: {:>8} ps, index: {:>8}".format(time_per_frame.loc[b, "time"], time_per_frame.loc[b, "iframe"]))
    print("Time end:  {:>8} ps, index: {:>8}".format(time_per_frame.loc[e, "time"], time_per_frame.loc[e, "iframe"]))
    print("Interval:", interval)
    return system.get_traj(b=b, e=e, i=interval)


def to_Continue_analysis(system, output, **kwargs):
    """Determine if the analysis continues from the last analyzed frame."""
    # begin frame
    b = 0
    if os.path.exists(output):
        dat = pd.read_csv(output)
        if len(dat) == 0:
            print("Blank file")
            return b

        # Remove incomplete frames.
        dat = clean_data(dat)
        dat.to_csv(output, index=False)
        frames_readed = list(pd.unique(dat["frame"]))
        # update file list
        system.update_xyz()

        if len(frames_readed) == len(system.XYZs):
            print("The number of XYZ files is equal to the number of\
 frames analyzed.")
            b = len(frames_readed)

        elif len(frames_readed) == len(system.GROs):
            print("The number of GRO files is equal to the number of\
 frames analyzed.")
            b = len(frames_readed)

        elif len(frames_readed) < len(system.XYZs):
            print("The number of XYZ files is greater than the number of\
 files analyzed.")
            b = len(frames_readed)

        elif len(frames_readed) < len(system.GROs):
            print("The number of GRO files is greater than the number of\
 files analyzed.")
            b = len(frames_readed)

    return b


def main():
    """Run main function."""
    print(TITLE)
    args = options()

    if args["donnees"]:
        system = STAMP(
            donnees=args["donnees"],
            data=args["dataStamp"],
            traj_type=args["traj_type"],
            nproc=args["NUMPROC"]
        )

        if args["traj_type"] == "XTC":
            print("Analysis will be performed using xtc file from gromacs.")
            assert args["top"] is not None, "If you are going to use XTC you must define a topology (gro)"
            assert args["xtc"] is not None, "There must be an xtc trajectory"
            system.top = args["top"]
            system.xtc = args["xtc"]

    elif args["fatomes"] and not args["donnees"]:
        print("Working with the system topology.")
        fatomes = TOPOL(args["fatomes"])
        print("FAtomes file:", fatomes.file)

    elif args["autocorrelation"]:
        print("Data processing analysis")

    else:
        print("The state of the system must be defined.")
        exit()

    # Initializes the trajectory variable
    traj = None

    # Others options:

    if isinstance(args["mol_traj"], int):
        resid = args["mol_traj"]
        print("Resid:", resid)
        if traj is None:
            traj = read_traj(system, **args)

        mol_ndx = system.atoms_per_mol[resid]
        connectivity = system.connectivity
        box_in_frame = system.box_in_frame
        time_per_frame = system.time_per_frame

        mol_traj_analysis(
            resid,
            mol_ndx,
            connectivity,
            traj,
            box_in_frame,
            o_format=args["format"]
        )

    # =============================================================================
    # Structural analysis functions
    # =============================================================================

    if args["molprop"]:
        # output name
        output = "molprop.csv"
        if args["reset"]:
            os.remove(output)
            print(f"File {output} removed.")

        # Run from the last frame analyzed
        b = to_Continue_analysis(system, output, **args)
        if b != 0:
            print("Start from frame:", b)

        if b == 0 and not args["reset"]:
            args["reset"] = True
        elif b > 0:
            traj = system.get_traj(b=b)

        if traj is None:
            traj = read_traj(system, **args)

        traj_analysis(
            system.atoms_per_mol,
            system.topology,
            traj,
            system.box_in_frame,
            system.connectivity,
            b=b,
            reset=args["reset"],
            nproc=args["NUMPROC"]
        )
        # save information in file
        print(f"file {output} saved.")

    if args["aggregate"] is not None:
        print(args["aggregate"])
        # output name
        output = "aggprop.csv"
        if args["reset"]:
            os.remove(output)
            print(f"File {output} removed.")

        def mol_selections(sel):
            """
            Generate a list of residues using an expression.

            Examples:
            ---------
            0 1 2 3 4 8

            0:20

            0 to 20
            """
            molecules = []

            if "to" in sel and len(sel) == 3:
                b = int(sel[0])
                e = int(sel[2])
                for sub_i in range(b, e + 1):
                    molecules.append(sub_i)

                return molecules

            for i in sel:
                if ":" in i:
                    b, e = i.split(":")
                    b = int(b)
                    e = int(e)
                    for sub_i in range(b, e + 1):
                        molecules.append(sub_i)
                else:
                    molecules.append(int(i))

            return molecules

        mols = mol_selections(args["aggregate"])

        # Run from the last frame analyzed
        b = to_Continue_analysis(system, output, **args)
        if b != 0:
            print("Start from frame:", b)

        if b == 0 and not args["reset"]:
            args["reset"] = True
        elif b > 0:
            traj = system.get_traj(b=b)

        if traj is None:
            traj = read_traj(system, **args)

        ndx_mols_atoms = {}
        for imol in mols:
            # print(imol, system.atoms_per_mol[imol])
            ndx_mols_atoms[imol] = system.atoms_per_mol[imol]["index"]

        traj_analysis_agg(
            ndx_mols_atoms,
            system.topology,
            traj,
            system.box_in_frame,
            system.connectivity,
            b=b,
            reset=args["reset"],
            nproc=args["NUMPROC"]
        )
        # save information in file
        print(f"file {output} saved.")
        print("file agg_traj.xyz saved.")

    if args["autocorrelation"]:
        geom = args["geom_file"]
        assert geom is not None, "You must select a geometry file using: --geom_file"
        print("Geometry file:", geom)
        t0 = args["t0"]
        freq = args["freq"]
    
        data = read_geometry_file(
            geom,
            freq=freq,
            t0=t0
        )
    
        print(data)
        resid = ""
        try:
            resid = int(geom.split(".")[0].split("_")[-1])
        except ValueError:
            pass
    
        angle = args["angle"]
        assert angle is not None, "You must define a angle from geometry file using: -angle/--angle"
        assert angle in data.columns, "The angle you selected is not found in the geometry file: " + " ".join(list(data.columns))
        print("Selected angle:", angle)
    
        acorr = {}
        acorr["acorr"] = get_acorr_function_angle(data[angle].values)
        acorr["time"] = data["time"].values
        acorrDF = pd.DataFrame(acorr)
        file = f"acf_{angle}_{resid}.csv"
        acorrDF.to_csv(file, float_format="%.6f", index=None)
        print(f"file {file} saved.")
    
    if args["closestDist"]:
        resid = args["mref"]
        # output name
        output = "closest_d_To_%d.csv" % resid
        if args["reset"]:
            os.remove(output)
            print(f"File {output} removed.")
    
            # Run from the last frame analyzed
        b = to_Continue_analysis(system, output, **args)
    
        if b == 0 and not args["reset"]:
            args["reset"] = True
        elif b > 0:
            traj = system.get_traj(b=b)
        
        if traj is None:
            traj = read_traj(system, **args)
    
        get_dist_from_closest_atom(
            resid,
            system.atoms_per_mol,
            system.topology, 
            traj,
            system.box_in_frame,
            system.connectivity,
            b=b,
            reset=args["reset"]
        )
        # save information in file
        print(f"file {output} saved.")
    
    if args["mol_d_aa"]:
        if traj is None:
            traj = read_traj(system, **args)
    
        mol_traj_cut_distance(
            traj,
            system.atoms_per_mol,
            system.topology,
            system.box,
            system.connectivity,
            ref=args["mref"],
            rcutoff=args["rcutoff"],
            out_folder=args["out_folder"]
        )
    
    if args["mol_d"]:
        print("Resid:", args["mref"])
        get_distances_from(args["mref"], system.box)
        print("file mol_dist_from_{}.csv saved.".format(args["mref"]))
    
    if args["centered_traj"]:
        # distances file
        mol_dist = pd.read_csv("mol_dist_from_{}.csv".format(args["mref"]))
        mol_dist["distance"] = mol_dist["distance"] * 0.1  # to nm
    
        # load center of mass file
        c_mass = pd.read_csv("molprop.csv")
    
        if traj is None:
            traj = read_traj(system, **args)
    
        gen_centered_traj(
            traj,
            system.atoms_per_mol,
            system.connectivity,
            system.box_in_frame,
            mol_dist,
            c_mass,
            rcutoff=args["rcutoff"],
            ref=args["mref"],
            out_folder=args["out_folder"])
    
    if args["ref_plane"]:
        print("Analysis using a plane")
    
        # Reference molecule using mref
        mref = args["mref"]
        print("Resid:", mref)
    
        # References atoms indexs
        atref = args["atref"]
        print("Index:", " ".join([str(i) for i in atref]))
    
        # File traj center of mass
        file = "molprop.csv"
    
        # Coordinates
        box = system.box
    
        time_per_frame = system.time_per_frame
        b = time_per_frame[time_per_frame["time"] >= args["b"]].index[0]
        if traj is None:
            traj = read_traj(system, **args)
    
        get_angles_distance(mref, atref, box, traj, file, b=b)
        print(f"file mol_angles_d_{mref}.csv saved.")
    
    if args["rdf"] is not None:
        # Reference molecule using mref
        mref = args["mref"]
        print("Resid:", mref)
    
        atoms_per_mol = system.atoms_per_mol
        connectivity = system.connectivity
        top = system.topology
        box = system.box
        vol = system.vol
        time_per_frame = system.time_per_frame
        if traj is None:
            traj = read_traj(system, **args)
    
        rdf_analysis(
            mref,
            args["rdf"],
            traj,
            atoms_per_mol,
            connectivity,
            top,
            box,
            vol,
            rmin=0.15,
        )
    
    # =============================================================================
    # Structural modifications
    # =============================================================================
    
    if args["add_hydrogen"]:
        fatomes.complete_with_H()
        # NEW OPTION: ref
        # atomsref = list(range(0, 26))  # photochromo
        atomsref = [4, 10, 11, 12]
        ###########################################################################
        # NEW OPTION: center system (on/off)
        fatomes.center_to(ref=atomsref, ref_type="atoms_ndx")
        fatomes.export_xyz("translate_to")
    
        # File
        fatomes.save_fatomes()
    
    if args["add_OH"]:
        fatomes.complete_with_OH()
        atomsref = [4, 10, 11, 12]
    
        fatomes.center_to(ref=atomsref, ref_type="atoms_ndx")
        fatomes.export_xyz("translate_to")
    
        # File
        fatomes.save_fatomes()
    
    if args["noPBC"]:
        fatomes.noPBC()


if __name__ == '__main__':
    main()
