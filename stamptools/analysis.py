"""Module dedicated to the analysis of trajectories generated by STAMP."""

import re
import time
import numpy as np
import pandas as pd
from scipy.constants import N_A
import os
from molcraft.structure import save_xyz, save_gro
from scipy.spatial.distance import cdist
from molcraft.clusters import GyrationTensor
from multiprocessing import Pool
import statsmodels.api as sm

# Maximum number of processors
NUMPROC = 12

""" Regular expression that extracts matrix XYZ """
atoms = re.compile(r"""
        ^\s*
        (?P<atsb>[A-Za-z]+\d?\d?[A-Za-z]*)\s+      # Atom name.
        (?P<x>[+-]?\d+\.\d+\w?[+-]?\d*)\s+           # Orthogonal coordinates for X.
        (?P<y>[+-]?\d+\.\d+\w?[+-]?\d*)\s+           # Orthogonal coordinates for Y.
        (?P<z>[+-]?\d+\.\d+\w?[+-]?\d*)\s+           # Orthogonal coordinates for Z.
        """, re.X)

""" Regular expression for .log """
out_mean = re.compile(r"""
    \s*
    (?P<frame>[\d,0]+)\s                      # Frame
    -\sCPU=(?P<cpu>\d+\.\w+[+-]?\d+)\s
    .+\s
    t=(?P<time>\d+\.\w+[+-]?\d+)
    """, re.X)

out_xyz = re.compile(r"""
    ^\s+[\*]+\sIteration\s
    (?P<frame>[\d,0]+)\s
    -\sSortie\sXYZ
    """, re.X)

out_gro = re.compile(r"""
    ^\s+[\*]+\sIteration\s
    (?P<frame>\d+)\s
    -\sSortie\sGRO
    """, re.X)

""" Regular expression for FAtomes """

noms = re.compile(r"""
    nom\s+(?P<nom>\w+)
    """, re.X)

masses = re.compile(r"""
    masse\s+(?P<mass>\d+\.\w+[+-]?\d+)
    """, re.X)

charges = re.compile(r"""
    charge\s+(?P<charge>[+-]?\d+\.\d+)
    """, re.X)


def decoTime(func):
    """Indicate the time elapsed in the execution of a function."""

    def elapsed_time(*args, **kwargs):
        """Print the elapsed time in the use of the function."""
        ti = time.perf_counter()
        func(*args, **kwargs)
        tf = time.perf_counter()
        print("done in {} s".format(round(tf - ti, 3)))

    return elapsed_time


def read_fatomes(file):
    """Read Fatomes file."""
    t0 = time.time()
    print("Reading fatomes file", end=" - ")
    natypes = 0
    atomsM = {}
    xyz = []
    lnom = []
    lmass = []
    lcharges = []
    lcharge_mod = []
    connects = dict()
    with open(file, "r") as FATM:
        nom = ""
        for line in FATM:
            if noms.match(line):
                nom = ""
                m = noms.match(line)
                lnom.append(m.groupdict())
                nom += m.groupdict()["nom"]

            if masses.match(line):
                m = masses.match(line)
                lmass.append(m.groupdict())

            if charges.match(line):
                m = charges.match(line)
                lcharges.append((nom, float(m.groupdict()["charge"])))
                nom = ""

            if "*" == line[0]:
                # ignore lines with the * symbol
                continue

            elif "NbTypesAtomes" in line:
                line = line.split()
                natypes += int(line[1])
                continue

            elif "maille_long" in line:
                line = line.split()
                box = np.array(line[1:4]).astype(np.float64)
                continue

            elif atoms.match(line):
                m = atoms.match(line)
                xyz.append(m.groupdict())

            elif "Zmatrice" in line:
                N = int(FATM.readline())
                # print("N conectivity:", N)
                for _ in range(N):
                    zline = FATM.readline()
                    zline = zline.split()
                    zline = [int(i) for i in zline]
                    connects[zline[0]] = zline[1:]

            elif "ModificationChargeDesAtomes" in line:
                N = int(FATM.readline())
                for _ in range(N):
                    chline = FATM.readline()
                    chline = chline.split()
                    lcharge_mod.append({"idx": int(chline[0]), "charge": float(chline[1])})
    
    lcharges = {key: charge for (key, charge) in lcharges}
    def from_lcharges(x):
        try:
            return lcharges[x]
        except KeyError:
            return 0.0

    lcharge_mod = pd.DataFrame(lcharge_mod)
    atomsM = dict()

    if len(lmass) == len(lnom):
        for i in range(len(lnom)):
            atomsM[lnom[i]["nom"]] = np.float64(lmass[i]["mass"])
            if lnom[i]["nom"][0].upper() == "H":
                atomsM[lnom[i]["nom"]] = np.float64(1.008e-03)

    else:
        print("\nERROR, no; and masses dont similar")
        exit()

    tabXYZ = pd.DataFrame(xyz)

    tabXYZ = tabXYZ.astype({
        "x": np.float64,
        "y": np.float64,
        "z": np.float64
    })

    try:
        tabXYZ["mass"] = tabXYZ["atsb"].apply(lambda x: atomsM[x])
    except KeyError:
        print("")
        print(atomsM)
        print(tabXYZ.loc[0:26, :])
        print("ERROR")
        exit()

    tabXYZ["charge"] = tabXYZ["atsb"].apply(from_lcharges)

    for i in lcharge_mod.index:
        tabXYZ.loc[lcharge_mod.loc[i, "idx"], "charge"] = lcharge_mod.loc[i, "charge"]

    tf = time.time()
    print(f"done in {tf-t0:.2f} s")

    return tabXYZ, box, connects


def progress(p):
    """Indicate on a bar the progress of the analysis."""
    bar = int(p * 40 / 100)
    return bar*"=" + (40-bar)*" "


def center_of_mass(coords, masses):
    """Compute the center of mass, the mass weighterd barycenter."""
    return np.sum(coords * masses[:, np.newaxis], axis=0) / masses.sum()


def center_of_mass_polar(coords, box, masses):
    """Compute the center of mass, the mass weighterd barycenter."""
    theta_i = coords / box * 2 * np.pi
    xi_i = np.cos(theta_i)
    eta_i = np.sin(theta_i)
    xi_m = np.sum(xi_i * masses[:, np.newaxis], axis=0) / masses.sum()
    eta_m = np.sum(eta_i * masses[:, np.newaxis], axis=0) / masses.sum()
    theta_m = np.arctan2(-eta_m, -xi_m) + np.pi
    
    return box * theta_m / 2 / np.pi


def get_properies_inFrame(frame, n_frame, molecules, top, connectivity, box):
    """Return the calculated properties for a particular frame."""
    lines = ""
    for mol in molecules:
        masses = top.loc[molecules[mol], "mass"].values
        dfcoord = frame.loc[molecules[mol], :]

        # Connectivity in the molecule
        connect = connectivity.sub_connect(molecules[mol])

        # update coordinates
        connect.update_coordinates(dfcoord)

        # remove PBC
        connect.noPBC(box, center=np.zeros(3))

        newdfcoord = connect.get_df()
        coord = newdfcoord.loc[:, ["x", "y", "z"]].values

        G = GyrationTensor(coord, masses, box, pbc=False)

        line = ""
        line += f"{n_frame},"
        line += f"{mol},"
        line += "{},".format(len(molecules[mol]))
        line += f"{G.iso_w_rg:.2f},"
        line += f"{G.shape_anisotropy:.3f},"
        line += f"{G.max_distance:.2f},"

        # Center of mass
        mol_cm = center_of_mass_polar(
            dfcoord.loc[:, ["x", "y", "z"]].values,
            box[0:3],
            masses
        )

        line += f"{mol_cm[0]:.3f},"
        line += f"{mol_cm[1]:.3f},"
        line += f"{mol_cm[2]:.3f}"
        line += "\n"

        lines += line

    return lines


def test_coor_mol(x, L):
    theta = x / L * 2 * np.pi
    xi = np.cos(theta)
    eta = np.sin(theta)
    theta_n = np.arctan2(-eta, -xi) + np.pi
    return L * theta_n / 2 / np.pi


def get_properies_inFrame_agg(frame, n_frame, molecules, top, connectivity, box):
    """Return the calculated properties for a particular frame."""
    lines = ""
    all_masses = []
    all_coords = []
    for mol in molecules:
        masses = top.loc[molecules[mol], "mass"].values
        dfcoord = frame.loc[molecules[mol], :]

        all_masses.append(masses)
        all_coords.append(dfcoord)

    masses = np.concatenate(all_masses)
    dfcoord_original = pd.concat(all_coords, ignore_index=True)

    # Center of mass
    agg_cm = center_of_mass_polar(
            dfcoord_original.loc[:, ["x", "y", "z"]].values,
            box[0:3],
            masses
        )

    all_coords = []

    for mol in molecules:
        dfcoord = frame.loc[molecules[mol], :]

        # Connectivity in the molecule
        connect = connectivity.sub_connect(molecules[mol])

        # update coordinates
        connect.update_coordinates(dfcoord)
        # remove PBC
        # connect.noPBC(box, center=agg_cm)
        connect.noPBC(box, center=None)
        connect.simple_at_symbols()
        newdfcoord = connect.get_df()

        ###TEST TRANSLATION
        newdfcoord.loc[:, ["x", "y", "z"]] = translate_to(
            newdfcoord.loc[:, ["x", "y", "z"]].values,
            agg_cm,
            box
        )
        ###TEST trigonometric correction
        # newdfcoord["x"] = newdfcoord["x"].apply(test_coor_mol, L=box[0])
        # newdfcoord["y"] = newdfcoord["y"].apply(test_coor_mol, L=box[1])
        # newdfcoord["z"] = newdfcoord["z"].apply(test_coor_mol, L=box[2])

        all_coords.append(newdfcoord)

    dfcoord = pd.concat(all_coords, ignore_index=True)

    lines_xyz = save_xyz(dfcoord, name=f"agg_{len(molecules)}", get_lines=True)

    coord = dfcoord.loc[:, ["x", "y", "z"]].values
    G = GyrationTensor(coord, masses, box, pbc=False)

    line = ""
    line += f"{n_frame},"
    line += "{},".format(len(molecules))
    line += f"{G.iso_w_rg:.2f},"
    line += f"{G.shape_anisotropy:.3f},"
    line += f"{G.max_distance:.2f},"

    # Center of mass
    mol_cm = center_of_mass_polar(
        dfcoord_original.loc[:, ["x", "y", "z"]].values,
        box[0:3],
        masses
    )

    line += f"{mol_cm[0]:.3f},"
    line += f"{mol_cm[1]:.3f},"
    line += f"{mol_cm[2]:.3f}"
    line += "\n"

    lines += line

    return lines, lines_xyz


@decoTime
def traj_analysis(ndx_mol, top, traj, box_in_frame, connectivity, b=0, reset=True, nproc=NUMPROC):
    """
    Analyze properties during a simulation.

    Parameters
    ----------
    ndx_mol : dict
        Dictionary with the indexes of each molecule to be analyzed.

    top : DataFrame
        File with the system topology.

    traj : list(DataFrame)
        Defines the trajectory of the system in a list of Dataframes.

    box : numpy.array (1x3)
        Vector box.

    connectivity : molcraft.structure.connectivity
        System connectivity.

    b : int
        initial frame.

    reset : boolean
        Write a new file.

    """
    print("Trajectory analysis", end=" - ")

    # Number of frames read
    Nframes = len(traj)
    print(f"Frame initial {b}", end=" - ")
    print(f"Number of frames: {Nframes}", end=" - ")

    if reset:
        if os.path.exists("molprop.csv"):
            os.remove("molprop.csv")
            print("File molprop.csv removed.")
        out = open("molprop.csv", "w")
        out.write("frame,idx,Natoms,Rg,k2,dmax,x,y,z\n")
        out.close()

    # List molecules present
    molecules = {}
    for mol in ndx_mol:
        if len(ndx_mol[mol]["index"]) == 1:
            continue
        molecules[mol] = ndx_mol[mol]["index"]

    arguments = []
    for i, frame in enumerate(traj):
        arguments.append(
            (frame, i + b, molecules, top, connectivity, box_in_frame[i])
        )

    lines = ""
    with Pool(processes=nproc) as pool:
        for lines_frame in pool.starmap(get_properies_inFrame, arguments):
            lines += lines_frame

    with open("molprop.csv", "a") as out:
        out.write(lines)


@decoTime
def traj_analysis_agg(ndx_mols_atoms, top, traj, box_in_frame, connectivity, b=0, reset=True, nproc=NUMPROC):
    """
    Analyze aggregate properties during a simulation.

    Parameters
    ----------
    ndx_mols_atoms : dict
        Dictionary with the indexes of each molecule to be analyzed.

    top : DataFrame
        File with the system topology.

    traj : list(DataFrame)
        Defines the trajectory of the system in a list of Dataframes.

    box : numpy.array (1x3)
        Vector box.

    connectivity : molcraft.structure.connectivity
        System connectivity.

    b : int
        initial frame.

    reset : boolean
        Write a new file.

    """
    print("Trajectory analysis", end=" - ")
    ndx_atoms = []
    for imol in ndx_mols_atoms:
        ndx_atoms += ndx_mols_atoms[imol]

    # Number of frames read
    Nframes = len(traj)
    print(f"Frame initial {b}", end=" - ")
    print(f"Number of frames: {Nframes}", end=" - ")

    if reset:
        if os.path.exists("aggprop.csv"):
            os.remove("aggprop.csv")
            print("File aggprop.csv removed.")
        out = open("aggprop.csv", "w")
        out.write("frame,Nmols,Rg,k2,dmax,x,y,z\n")
        out.close()

    # List molecules present
    molecules = ndx_mols_atoms.copy()

    arguments = []
    for i, frame in enumerate(traj):
        arguments.append(
            (frame, i + b, molecules, top, connectivity, box_in_frame[i])
        )

    lines = ""
    traj_xyz = ""
    with Pool(processes=nproc) as pool:
        for lines_frame, lines_xyz in pool.starmap(get_properies_inFrame_agg, arguments):
            lines += lines_frame
            traj_xyz += lines_xyz

    with open("aggprop.csv", "a") as out:
        out.write(lines)

    with open("agg_traj.xyz", "w") as out:
        out.write(traj_xyz)


def load_data(file, t="LNVT"):
    """
    Load data from Stamp.dat.

    Parameters:
    -----------
    file : str
        Output file from STAMP.

    t : str
        Simulation type: LNVT or NPT.

    """
    names = {
        "LNVT": [
            "time",
            "Etot", "Epot", "Epot_intra", "Epot_inter", "Ekin",
            "T", "Tx", "Ty", "Tz",
            "P", "Px", "Py", "Pz",
            "Vx", "Vy", "Vz",
            "D", "cpu"],
        "NPT": [
            "time",
            "Etot", "Epot", "Epot_intra", "Epot_inter", "Ekin",
            "T", "Tx", "Ty", "Tz",
            "P", "Px", "Py", "Pz",
            "Cmvx", "Cmvy", "Cmvz",
            "Lx", "Ly", "Lz",
            "Vx", "Vy", "Vz",
            "Dens",
            "D", "cpu"
        ]}
    data = pd.read_csv(
        file,
        sep=r"\s+",
        header=None,
        names=names[t],
        comment="#"
                      )
    data["Etot"] = data["Etot"] * N_A / 1000  # to kJ/mol
    data["Epot"] = data["Epot"] * N_A / 1000  # to kJ/mol
    data["Epot_intra"] = data["Epot_intra"] * N_A / 1000  # to kJ/mol
    data["Epot_inter"] = data["Epot_inter"] * N_A / 1000  # to kJ/mol
    data["Ekin"] = data["Ekin"] * N_A / 1000  # to kJ/mol
    data["time"] = data["time"] * 1e12  # to ps
    data["P"] = data["P"] * 1e-5  # to bar

    return data


def load_log(file="Stamp.log", use_xyz=True, traj_type="XYZ"):
    """
    Load info from file log Stamp.

    Args:
        file (str): Output file from STAMP (log).

    Returns:
        DataFrame: Frame per time.

    """
    print("Reading log file", end=" - ")
    t0 = time.time()
    out_g = []
    out_frame = []
    status = "Not finished"
    dt = 0
    frame_init = 0
    with open(file, "r") as LOG:
        for line in LOG:
            if out_mean.match(line):
                m = out_mean.match(line)
                out_g.append(m.groupdict())

            if traj_type == "XYZ":
                if out_xyz.match(line):
                    m = out_xyz.match(line)
                    out_frame.append(m.groupdict())
            elif traj_type == "GRO" or traj_type == "XTC":
                if out_gro.match(line):
                    m = out_gro.match(line)
                    out_frame.append(m.groupdict())

            if "Nom du fichier de reprise" in line:
                frame_init = int(line.split()[-1].split("_")[-1].split(".")[0])

            if "Deltatemps" in line:
                dt = float(line.split()[-1]) * 1e12  # to ps

            if "Arret normal du calcul" in line:
                status = "finished"

    print("time step detected (ps):", dt)
    out_g = pd.DataFrame(out_g)
    out_g.drop_duplicates(inplace=True, ignore_index=True)
    print("Initial time detected (ps):", out_g["time"].values[0])
    print("Initial frame:", frame_init)

    ### MODIFICATION
    out_frame = pd.DataFrame(out_frame)
    out_frame.drop_duplicates(inplace=True, ignore_index=True)
    try:
        out_frame = out_frame.astype({"frame": np.int64})
    except KeyError:
        mess = "The system frames have not been recognized, check that the typ\
e of trajectory is correct. option: --traj_type [XYZ, GRO, XTC]"
        raise KeyError(mess)
    out_frame["iframe"] = np.arange(len(out_frame))
    out_frame["step_frame"] = out_frame["frame"] - frame_init
    out_frame["time"] = out_frame["step_frame"] * dt

    return out_frame, status
    """

    if use_xyz:
        out_g.set_index("frame", inplace=True)
        frame_dict = out_g["time"].to_dict()

        out_frame = pd.DataFrame(out_frame)
        out_frame.drop_duplicates(inplace=True, ignore_index=True)

        time_f = []
        try:
            for t in out_frame["frame"]:
                try:
                    if t == "0":
                        time_f.append("0.000")
                    else:
                        time_f.append(frame_dict[t])
                except KeyError:
                    time_f.append(np.NaN)
        except KeyError:
            print(f"No frame found, check the type of trajectory loaded. {traj_type}")
            exit()

        # out_frame["time"] = out_g.loc[out_frame["frame"].values, "time"].unique()
        out_frame["time"] = time_f
        out_frame.dropna(inplace=True)
        out_frame = out_frame.astype(
            {"frame": np.int64, "time": np.float64}
        )
        out_frame["time"] = out_frame["time"] * 1e12  # to ps
        out_frame["iframe"] = np.arange(len(out_frame))

        print(f"done in {time.time()-t0:.2f} s")
        return out_frame, status

    else:
        out_g = out_g.astype(
            {"frame": np.int64, "time": np.float64, "cpu": np.float64}
        )
        out_g.set_index("frame", inplace=True)
        out_g["time"] *= 1e12  # to ps
        out_g["iframe"] = np.arange(len(out_g))
        print(f"done in {time.time()-t0:.2f} s")
        return out_g, status
    """


def get_density(XYSs):
    """Return density of system using xyz stamp files."""
    pass


def traj_center_mass(traj, ndx_mol, top, box, connectivity, b=0, reset=True):
    """Return the center of mass of each molecule over time."""
    print("Center of mass analysis")
    t0 = time.time()

    # Number of frames read
    Nframes = len(traj)
    print(f"Number of frames: {Nframes}")

    if reset:
        out = open("molprop.csv", "w")
        out.write("frame,idx,Natoms,x,y,z\n")
        out.close()

    for n_frame, frame in enumerate(traj):
        porcent = n_frame * 100 / Nframes
        print(f"{porcent:6.2f} % |{progress(porcent)}|")
        if n_frame < b:
            continue
        for mol in ndx_mol:
            masses = top.loc[ndx_mol[mol]["index"], "mass"].values
            dfcoord = frame.loc[ndx_mol[mol]["index"], :]

            # Connectivity in the molecule
            connect = connectivity.sub_connect(ndx_mol[mol]["index"])

            # update coordinates
            connect.update_coordinates(dfcoord)

            # remove PBC
            connect.noPBC(box, center=np.zeros(3))

            # extract new coordinates
            newdfcoord = connect.get_df()
            coord = newdfcoord.loc[:, ["x", "y", "z"]].values

            mol_cm = center_of_mass(coord, masses)

            line = ""
            line += f"{n_frame},"
            line += f"{mol},"
            line += "{},".format(int(ndx_mol[mol]["Natoms"]))
            line += f"{mol_cm[0]:.3f},"
            line += f"{mol_cm[1]:.3f},"
            line += f"{mol_cm[2]:.3f}"
            line += "\n"
            # print(line)

            with open("molprop.csv", "a") as out:
                out.write(line)
            
    print(f"{100:6.2f} % |{progress(100)}|")
    tf = time.time()
    print(f"Analysis time: {tf-t0:.2f} s")


def minImagenC(q1, q2, L):
    # q1---->q2 = q2 - q1
    dq = q2 - q1
    if dq > L * 0.5:
        dq -= L
    
    if dq <= -L * 0.5:
        dq += L
    
    return dq


def get_distances_from_cm(mref, molprop, box_in_frame):
    """Return distances from center of mass list."""
    # file cm trajectory
    traj_mol_cm = molprop.loc[:, ["frame", "idx", "x", "y", "z"]] .copy()
    traj_mol_cm["frame"] = traj_mol_cm["frame"].astype(np.int64)
    traj_mol_cm["idx"] = traj_mol_cm["idx"].astype(np.int64)
    
    # cm trajectory from ref
    traj_mref = traj_mol_cm[traj_mol_cm["idx"] == mref]
    
    # cm trajectory from others
    traj_not_mref = traj_mol_cm[traj_mol_cm["idx"] != mref]
    
    # Data
    frame_list = []
    resid_list = []
    distance_list = []
    
    for frame in traj_mref["frame"].values:
        mref_xyz = traj_mref[traj_mref["frame"] == frame].loc[:, ["x", "y", "z"]].values[0]
        not_mref_xyz = traj_not_mref[traj_not_mref["frame"] == frame].loc[:, ["idx", "x", "y", "z"]].values
        box = box_in_frame[frame][0:3]
        for mol in not_mref_xyz:
            # int
            pol_id = int(mol[0])
            # [float, float, float]
            mol = mol[1:]
            # One distance at a time
            dist = PBC_distance(mref_xyz, mol, box)
            frame_list.append(frame)
            resid_list.append(pol_id)
            distance_list.append(dist)
            
    return pd.DataFrame({
        "frame": frame_list,
        "idx": resid_list,
        "distance": distance_list
    })


def closest_distance_inFrame(mol_ref, frame, n_frame, molecules, top, connectivity, box):
    """Distance from closest atoms in a frame."""
    line = ""
    mref_xyz = frame.loc[mol_ref, ["x", "y", "z"]].values
    # print(mref_xyz)
    for mol in molecules:
        mol_coord = frame.loc[molecules[mol], ["x", "y", "z"]].values
        matrix_dist = cdist(
            mref_xyz, mol_coord, lambda a, b: PBC_distance(a, b, box)
        )
        min_distance = matrix_dist.min()
        at_i, at_j = list(zip(*np.where(matrix_dist == min_distance)))[0]

        line += f"{n_frame},"
        line += f"{mol},"
        line += f"{mol_ref[at_i]},"
        line += f"{molecules[mol][at_j]},"
        line += f"{min_distance:.6f}"
        line += "\n"

    return line


@decoTime
def get_dist_from_closest_atom(resid, ndx_mol, top, traj, box_in_frame, connectivity, b=0, reset=True):
    """Return distances from closest atoms."""
    print("Trajectory analysis Closest distance", end=" - ")
    print(f"resid {resid}", end=" - ")
    # Number of frames read
    Nframes = len(traj)
    print(f"Frame initial {b}", end=" - ")
    print(f"Number of frames: {Nframes}", end=" - ")

    output = "closest_d_To_%d.csv" % resid
    if reset:
        out = open(output, "w")
        out.write("frame,idx,at_i,at_j,distance\n")
        out.close()

    # List molecules present
    molecules = {}
    for mol in ndx_mol:
        if len(ndx_mol[mol]["index"]) == 1:
            continue
        if mol != resid:
            molecules[mol] = ndx_mol[mol]["index"]

    mol_ref = ndx_mol[resid]["index"]

    arguments = []
    for i, frame in enumerate(traj):
        arguments.append(
            (
                mol_ref,
                frame,
                i + b,
                molecules,
                top, connectivity,
                box_in_frame[i, 0:3]
            )
        )

    lines = ""
    with Pool(processes=NUMPROC) as pool:
        for lines_frame in pool.starmap(closest_distance_inFrame, arguments):
            lines += lines_frame

    with open(output, "a") as out:
        out.write(lines)


def get_distances_from(mref, box, file="molprop.csv"):
    """Dsitance from center of mass."""
    # file cm trajectory
    traj_mol_cm = pd.read_csv(file)
    # print(traj_mol_cm.isnull().values.any())
    # exit()
    traj_mol_cm["frame"] = traj_mol_cm["frame"].astype(np.int64)
    traj_mol_cm["idx"] = traj_mol_cm["idx"].astype(np.int64)

    # cm trajectory from ref
    traj_mref = traj_mol_cm[traj_mol_cm["idx"] == 0]

    # cm trajectory from others
    traj_not_mref = traj_mol_cm[traj_mol_cm["idx"] != 0]

    out = open(f"mol_dist_from_{mref}.csv", "w")
    out.write("frame,idx,distance\n")
    out.close()

    for frame in traj_mref["frame"]:
        print("frame", frame)
        mref_xyz = traj_mref[traj_mref["frame"] == frame].loc[:, ["x", "y", "z"]].values[0]
        # print(mref_xyz)
        not_mref_xyz = traj_not_mref[traj_not_mref["frame"] == frame].loc[:, ["idx", "x", "y", "z"]].values
        for mol in not_mref_xyz:
            pol_id = int(mol[0])
            #  print("Polimer id", pol_id)
            mol = mol[1:]
            dist = []
            for i in range(3):
                ndist = minImagenC(mref_xyz[i], mol[i], box[i])
                # ndist = mol[i] - mref_xyz[i]
                dist.append(ndist)
            dist = np.linalg.norm(dist)
            #print("distance", dist)
            line = ""
            line += f"{frame},"
            line += f"{pol_id},"
            line += f"{dist:.3f}"
            line += "\n"
            
            with open(f"mol_dist_from_{mref}.csv", "a") as out:
                out.write(line)


def get_angles_distance(mref, atref, box, traj, file="mol_cmass", b=0):

    def vecPBC(r1, r2, L):
        nr2 = np.zeros(3)
        for i in range(3):
            nr2[i] = minImagenC(r1[i], r2[i], L[i]) + r1[i]

        return nr2

    def VecNormal(atoms):
        # at1 is the reference atom
        at1 = atoms[0, :]
        at2 = atoms[1, :]
        at3 = atoms[2, :]

        #######
        # center
        nat2 = vecPBC(at1, at2, box)
        nat3 = vecPBC(at1, at3, box)

        #######
        # at1 --> natn
        #
        #            nat2
        #           /
        # at1      /
        #    \nat3/
        #
        v12 = nat2 - at1
        v13 = nat3 - at1

        return np.cross(v13, v12)

    # file cm trajectory
    traj_mol_cm = pd.read_csv(file)
    if b != 0:
        traj_mol_cm = traj_mol_cm[traj_mol_cm["frame"] >= b].copy()

    # cm trajectory from ref
    traj_mref = traj_mol_cm[traj_mol_cm["idx"] == mref]

    # cm trajectory from others
    traj_not_mref = traj_mol_cm[traj_mol_cm["idx"] != mref]

    out = open(f"mol_angles_d_{mref}.csv", "w")
    out.write("frame,idx,distance,cos,angles\n")
    out.close()
    iframe = 0

    for frame in traj_mref["frame"]:
        print("frame", frame)
        coord = traj[iframe]
        # print(coord)
        cm_ref = traj_mref[traj_mref["frame"] == frame].loc[:, ["x", "y", "z"]].values[0]
        # print("center of mass mol ref", cm_ref)

        atxyz = coord.loc[atref, ["x", "y", "z"]].values

        vnorm = VecNormal(atxyz)
        # print("Vector normal", vnorm)
        # c_vnorm = vnorm + cm_ref

        not_mref_xyz = traj_not_mref[traj_not_mref["frame"] == frame].loc[:, ["idx", "x", "y", "z"]].values
        for mol in not_mref_xyz:
            mol_id = int(mol[0])
            # print("molecule id", mol_id)

            mol_xyz = mol[1:]

            new_mol_xyz = vecPBC(cm_ref, mol_xyz, box)

            cm_ref_new_mol_xyz = new_mol_xyz - cm_ref

            distance_cm_mol = np.linalg.norm(cm_ref_new_mol_xyz)

            cos_th = np.dot(cm_ref_new_mol_xyz, vnorm) / np.linalg.norm(cm_ref_new_mol_xyz) / np.linalg.norm(vnorm)

            theta = np.arccos(cos_th) * 180.0 / np.pi

            line = ""
            line += f"{frame},"
            line += f"{mol_id},"
            line += f"{distance_cm_mol:.3f},"
            line += f"{cos_th:.2f},"
            line += f"{theta:.2f}"
            line += "\n"

            with open(f"mol_angles_d_{mref}.csv", "a") as out:
                out.write(line)

        iframe += 1


def translate_to(coord, center, box):
    """Translate coordinates using a reference center."""
    newcoord = np.zeros(coord.shape)
    for i, atom in enumerate(coord):
        for j, q in enumerate(atom):
            newcoord[i, j] = minImagenC(center[j], q, box[j])
    
    return newcoord


def change_atsb(x):
    """Change atom types to simple symbols."""
    if x in ["ca", "cb", "CT", "CM", "C"]:
        return "C"
    elif x in ["ha", "ho", "HT", "HM", "H"]:
        return "H"
    elif x in ["nf", "ne", "N"]:
        return "N"
    elif x in ["oh", "O"]:
        return "O"
    elif x in ["DU"]:
        return "DU"
    else:
        print(f"WARNING: {x} atom not reconize.")
        return x


def gen_centered_traj(
    traj, atoms_per_mol, connectivity, box, mol_dist,
    c_mass, rcutoff=1.5, ref=0, out_folder="centered_traj"
):
    """Generate a trajectory of the system using a reference center."""
    traj_resid_in_r = mol_dist[mol_dist["distance"] <= rcutoff]
    traj_center_ref = c_mass[c_mass["idx"] == ref].loc[:, ["x", "y", "z"]].values

    # Output folder
    try:
        os.mkdir(out_folder)
    except FileExistsError:
        print("The output foler was already created")
        
    for frame, coord in enumerate(traj):
        name = "centered_mol_%08d" % frame
        
        resid = [ref] + list(traj_resid_in_r["idx"][traj_resid_in_r["frame"] == frame].values)
        center = traj_center_ref[frame]
        
        # atoms_ndx = []
        ncoords = []
        for res in resid:
            atoms = atoms_per_mol[res]["index"]
            mol_conn = connectivity.sub_connect(atoms)
            df = coord.loc[atoms, :]
            # Translate to a center of reference
            df.loc[:, ["x", "y", "z"]] = translate_to(df.loc[:, ["x", "y", "z"]].values, center, box)
            # update coordinates
            mol_conn.update_coordinates(df)
            # remove PBC
            mol_conn.noPBC(box, center=np.zeros(3))
            # Reset index and symbols, and add mass
            mol_conn = mol_conn.reset_nodes()
            mol_conn.simple_at_symbols()

            # Search and add hydrogen to vacant atoms
            mol_conn.add_hydrogen(type_add="terminal-C")
            new_mol_xyz = mol_conn.get_df()
            ncoords.append(new_mol_xyz)
            # ndf = mol_conn.get_df()
            # connects.update_coordinates(ndf)
            # atoms_ndx += atoms
        ####
        # sys_conn = connects.sub_connect(atoms_ndx)
        # new df
        # ndf = sys_conn.get_df()
        # ndf["atsb"] = ndf["atsb"].apply(change_atsb).values.astype(str)
        ncoords = pd.concat(ncoords, ignore_index=True)

        if o_format == "xyz":
            save_xyz(ncoords, name=f"{out_folder}/{name}")


@decoTime
def mol_traj_analysis(index, mol_ndx, connectivity, traj, box_in_frame, o_format="xyz"):
    """Analyze trajectory of a particular molecule."""
    print("Gen trajectory for a mol, resid: ", index, end=" - ")
    name_last = ""

    def test_coor_mol(x, L):
        theta = x / L * 2 * np.pi
        xi = np.cos(theta)
        eta = np.sin(theta)
        theta_n = np.arctan2(-eta, -xi) + np.pi
        return L * theta_n / 2 / np.pi

    for i, xyz in enumerate(traj):
        name = "mol_%d_%08d" % (index, i)
        box = box_in_frame[i][0:3]

        mol_xyz = xyz.loc[mol_ndx["index"], :]
        ###TEST TRANSLATION
        mol_xyz.loc[:, ["x", "y", "z"]] = translate_to(
            mol_xyz.loc[:, ["x", "y", "z"]].values,
            np.array([30., 30., 30.]),
            box
        )
        ###TEST trigonometric correction
        mol_xyz["x"] = mol_xyz["x"].apply(test_coor_mol, L=box[0])
        mol_xyz["y"] = mol_xyz["y"].apply(test_coor_mol, L=box[1])
        mol_xyz["z"] = mol_xyz["z"].apply(test_coor_mol, L=box[2])

        mol_conn = connectivity.sub_connect(mol_ndx["index"])
        # update coordinates
        mol_conn.update_coordinates(mol_xyz)

        # remove PBC
        mol_conn.noPBC(box, center=np.zeros(3))

        # Reset index and symbols, and add mass
        mol_conn = mol_conn.reset_nodes()
        mol_conn.simple_at_symbols(add_mass=True)

        # Search and add hydrogen to vacant atoms
        mol_conn.add_hydrogen(type_add="terminal-C")
        new_mol_xyz = mol_conn.get_df()

        cm = center_of_mass(
            new_mol_xyz.loc[:, ["x", "y", "z"]].values,
            new_mol_xyz.loc[:, "mass"].values
        )

        new_mol_xyz["x"] -= cm[0]
        new_mol_xyz["y"] -= cm[1]
        new_mol_xyz["z"] -= cm[2]

        if o_format == "xyz":
            save_xyz(new_mol_xyz, name=name)

        elif o_format == "gro":
            new_mol_xyz["resname"] = "MOL"
            new_mol_xyz["resid"] = index + 1
            # CHAGE ########
            time = i * 1.0 + 501.0
            ################
            save_gro(new_mol_xyz, name=name, box=box, time=time)

        name_last = name

    if o_format == "xyz":
        os.system(f"cat mol_{index}_* > mol_traj_{index}.xyz")
        os.system(f"rm mol_{index}_*")
    elif o_format == "gro":
        print(f"Last frame: {name_last}", end=" - ")
        os.system(f"cp {name_last}.gro mol.gro")
        os.system(f"cat mol_{index}_0* > traj_mol_{index}.gro")
        os.system(f"rm mol_{index}_0*")
        os.system(f"gmx trjconv -f traj_mol_{index}.gro -o traj_comp_mol_{index}.xtc")


def PBC_distance(vref, v2, box):
    """Distance between two coordinates in periodic boundary conditions."""
    dist = []
    for i in range(len(box)):
        ndist = minImagenC(vref[i], v2[i], box[i])
        dist.append(ndist)
    
    return np.linalg.norm(np.array(dist))


def mol_traj_cut_distance(traj, atoms_per_mol, top, box, connectivity, ref, rcutoff=0.5, out_folder="mol_distances"):
    """Extract the structure of mol around a reference mol using atom-atom distance."""
    print(f"Extract the structure of molecules around a reference mol, resid {ref},")
    print(f"using atom-atom from a distance cut: {rcutoff:.2f} nm.")

    out_folder = out_folder + f"_{rcutoff}"
    rcutoff *= 10.
    masses = top.loc[atoms_per_mol[ref]["index"], "mass"].values

    # Output folder
    try:
        os.mkdir(out_folder)
    except FileExistsError:
        print("The output foler was already created")

    for frame, coord in enumerate(traj):
        name = "mol_around_%08d" % frame
        atoms_ref = atoms_per_mol[ref]["index"]
        mol_conn = connectivity.sub_connect(atoms_ref)
        mol_ref = coord.loc[atoms_ref, :]
        mol_xyz = mol_ref.loc[:, ["x", "y", "z"]].values

        mols_around = []
        for j in atoms_per_mol:
            if j != ref:
                # print(j)
                atoms_near = atoms_per_mol[j]["index"]
                # mol_conn_near = connectivity.sub_connect(atoms_near)
                mol_ref_near = coord.loc[atoms_near, :]
                mol_xyz_near = mol_ref_near.loc[:, ["x", "y", "z"]].values
                # print(mol_xyz_near)
                ##### DISTANCE Search
                for v_ref in mol_xyz:
                    new_mol = False
                    for v_near in mol_xyz_near:
                        r = PBC_distance(v_ref, v_near, box)
                        if r <= rcutoff:
                            mols_around.append(j)
                            new_mol = True
                            break
                    if new_mol:
                        break
                #####

        # update coordinates
        mol_conn.update_coordinates(mol_ref)
        # remove PBC
        mol_conn.noPBC(box, center=np.zeros(3))
        mol_coord = mol_conn.get_df()
        co = mol_coord.loc[:, ["x", "y", "z"]].values
        center = center_of_mass(co, masses)
        resids = [ref] + mols_around
        ncoords = []
        for res in resids:
            atoms = atoms_per_mol[res]["index"]
            mol_conn = connectivity.sub_connect(atoms)
            df = coord.loc[atoms, :]
            # Translate to a center of reference
            df.loc[:, ["x", "y", "z"]] = translate_to(df.loc[:, ["x", "y", "z"]].values, center, box)
            # update coordinates
            mol_conn.update_coordinates(df)
            # remove PBC
            mol_conn.noPBC(box, center=np.zeros(3))
            # Reset index and symbols, and add mass
            mol_conn = mol_conn.reset_nodes()
            mol_conn.simple_at_symbols()

            # Search and add hydrogen to vacant atoms
            mol_conn.add_hydrogen(type_add="terminal-C")
            new_mol_xyz = mol_conn.get_df()
            ncoords.append(new_mol_xyz)
            
        ncoords = pd.concat(ncoords, ignore_index=True)
        save_xyz(ncoords, name=f"{out_folder}/{name}")


def rdf_from_dist(df, box_in_frame, rmin=0.0, rmax=6.0, binwidth=0.002, atoms_ref=1, n_mol=72, n_replique=1):
    """Return rdf data and binned function."""
    def binned_distance(x):
        bins = np.arange(rmin, rmax, binwidth)
        index = np.digitize(x, bins)

        if x < rmin - binwidth:
            return np.NaN

        try:
            return bins[index]
        except IndexError:
            return np.NaN

    df = df.copy()
        
    df["bin"] = df["distance"].apply(binned_distance)

    frames = df["frame"].unique()
    n_frames = len(frames)
    n_mol = n_mol * n_replique #  df["distance"].count() / n_frames

    # Box in nanometers
    box = np.mean(box_in_frame[:, 0:3], axis=0)
    vol_per_com = box[0] * box[1] * box[2] / n_mol
    
    rdf = df.groupby("bin").count()
    rdf.reset_index(inplace=True)
    
    rdf["vshell"] = 4 * np.pi * ((binwidth + rdf["bin"])**3 - rdf["bin"]**3) / 3
    
    rdf["gr"] = rdf["distance"] * vol_per_com / rdf["vshell"] / n_frames / atoms_ref
    rdf["weight"] = vol_per_com / rdf["vshell"] / n_frames / atoms_ref
    
    try:
        return rdf.drop(columns=["frame", "idx", "at_i", "at_j", "distance"])
    except KeyError:
        return rdf


def get_frame_distances_cm(traj, ref, near, cmass, box, rcutoff):
    """Distances per frame from center of mass references."""
    frame_distances = {}
    neighbor_list = set()
    nstlist = 1

    for frame, coord in enumerate(traj):

        # # ==== NEIGHBOR SEARCHING ====
        # # Update the neighbor list every nstlist iterations
        # if frame % nstlist == 0:
        #     neighbor_list = set()
        #     neighbor = []
        #     for j in near:
        #         mol_i = coord.loc[ref, ["x", "y", "z"]].values
        #         mol_j = coord.loc[j, ["x", "y", "z"]].values
        #         if PBC_distance(mol_i, mol_j, box) <= rcutoff * 10.0:
        #             neighbor.append(j)

        #      neighbor_list.update(neighbor.copy())

        ncoord = cmass[cmass["frame"] == frame].reset_index()
        mol_ref_xyz = ncoord.loc[[ref], ["x", "y", "z"]].values
        mol_near_xyz = ncoord.loc[near, ["x", "y", "z"]].values

        frame_distances[frame] = cdist(
            mol_ref_xyz, mol_near_xyz, lambda a, b: PBC_distance(a, b, box)
        )

    return frame_distances


def get_frame_distances(traj, atoms_ref, atoms_near, box, rcutoff):
    """Distances per frame from atoms references."""
    frame_distances = {}
    # neighbor_list = set()
    # nstlist = 1

    for frame, coord in enumerate(traj):
        ## ==== NEIGHBOR SEARCHING ====
        ## Update the neighbor list every nstlist iterations
        #if frame % nstlist == 0:
        #    neighbor_list = set()
        #    for i in atoms_ref:
        #        neighbor = []
        #        for j in atoms_near:
        #            if i == j:
        #                continue
        #            at_i = coord.loc[i, ["x", "y", "z"]].values
        #            at_j = coord.loc[j, ["x", "y", "z"]].values

        #            if PBC_distance(at_i, at_j, box) <= rcutoff * 10.0:
        #                neighbor.append(j)

        #        neighbor_list.update(neighbor.copy())
        
        mol_ref = coord.loc[atoms_ref, :]
        mol_xyz = mol_ref.loc[:, ["x", "y", "z"]].values

        mol_near = coord.loc[atoms_near, :]
        mol_xyz_near = mol_near.loc[:, ["x", "y", "z"]].values

        frame_distances[frame] = cdist(
            mol_xyz, mol_xyz_near, lambda a, b: PBC_distance(a, b, box)
        )

    return frame_distances


@decoTime
def rdf_analysis(ref, atoms, traj, atoms_per_mol, connectivity, top, box, vol, rmin=0.0, rmax=3.0, binwidth=0.05, name="rdf"):
    """Calculate the RDF of a molecule and its environment."""
    print("RDF analysis:", atoms, end=" - ")
    ########################################
    # TRY to chage
    # read molecules center of mass
    #molp = pd.read_csv("molprop.csv")
    ########################################

    # RDF type
    if atoms == "all":
        atoms_ref = atoms_per_mol[ref]["index"]
        atoms_near = []
        for i in atoms_per_mol:
            if i != ref:
                atoms_near += atoms_per_mol[i]["index"]
        name += "_all"
    elif atoms == "cm":
        atoms_ref = "cm"
        name += "_cm"
        molp = pd.read_csv("molprop.csv")
        atoms_near = []
        for i in atoms_per_mol:
            if i != ref:
                atoms_near.append(i)
    else:
        atoms_ref = [int(a) for a in atoms.split("-")]
        name += "_" + "-".join(list(top.loc[atoms_ref, "atsb"].values))

    # Define the bins
    bins = np.arange(rmin, rmax + binwidth, binwidth)
    # print(len(atoms_ref))
    # print(len(atoms_near))

    # Obtains the distances per frames
    if atoms == "cm":
        frame_distances = get_frame_distances_cm(traj, ref, atoms_near, molp, box, rcutoff=rmax)
    else:
        frame_distances = get_frame_distances(traj, atoms_ref, atoms_near, box, rcutoff=rmax)

    ## if atoms_ref == "cm":
    ##     n_centers = 1
    ## else:
    ##     n_centers = len(atoms_ref)

    # total_n_centers = len(atoms_per_mol) - 1 + n_centers
    # vol_per_sphere = vol.mean() / total_n_centers
    ###vol_per_sphere = vol.mean() / (len(atoms_per_mol) - 1)
    ###vshell = 4 * np.pi * ((binwidth + bins)**3 - bins**3) / 3

    vol_per_sphere = vol.mean() / len(atoms_near)
    vshell = 4 * np.pi * ((binwidth + bins)**3 - bins**3) / 3

    # rdf
    g_r = np.zeros(len(bins))
    for frame in frame_distances:
        for atoms_distances in frame_distances[frame]:
            indexs = np.int64(atoms_distances * 0.1 / binwidth)
            indexs = indexs[indexs < len(bins)]
            for n in indexs:
                g_r[n] += 1

    n_frames = len(frame_distances.keys())
    g_r_norm = g_r * vol_per_sphere / vshell / n_frames / len(atoms_ref)

    # return g_r_norm, bins
    RDF = pd.DataFrame({
        "g_r": g_r_norm,
        "r": bins
    })

    file = f"{name}.csv"
    RDF.to_csv(file, float_format="%.6f", index=None)
    print(f"file {file} saved.", end=" - ")


def get_acorr_function_angle(angle):
    """Return autocorrelation function."""
    cos_a = np.cos(np.deg2rad(angle))
    acorr = sm.tsa.acf(cos_a, nlags = len(cos_a)-1)
    return acorr
