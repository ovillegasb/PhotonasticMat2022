"""Module dedicated to the analysis of trajectories generated by STAMP."""

import re
import time
import numpy as np
import pandas as pd
from scipy.constants import N_A
import pickle
import matplotlib.pyplot as plt
import seaborn as sns
import os
from molcraft.structure import save_xyz
from scipy.stats import linregress


""" Regular expression that extracts matrix XYZ """
atoms = re.compile(r"""
        ^\s+
        (?P<atsb>[A-Za-z]+\d?\d?)\s+      # Atom name.
        (?P<x>[+-]?\d+\.\d+)\s+           # Orthogonal coordinates for X.
        (?P<y>[+-]?\d+\.\d+)\s+           # Orthogonal coordinates for Y.
        (?P<z>[+-]?\d+\.\d+)\s+           # Orthogonal coordinates for Z.
        """, re.X)

""" Regular expression for .log """
out_mean = re.compile(r"""
    \s*
    (?P<frame>\d+)\s                      # Frame
    -\sCPU=(?P<cpu>\d+\.\w+[+-]?\d+)\s
    .+\s
    t=(?P<time>\d+\.\w+[+-]?\d+)
    """, re.X)

out_xyz = re.compile(r"""
    ^\s+[\*]+\sIteration\s
    (?P<frame>\d+)\s
    -\sSortie\sXYZ
    """, re.X)

""" Regular expression for FAtomes """

noms = re.compile(r"""
    nom\s+(?P<nom>\w+)               # Atom name
    """, re.X)

masses = re.compile(r"""
    masse\s+(?P<mass>\d+\.\w+[+-]?\d+)               # Atom name
    """, re.X)


def read_fatomes(file):
    """Read Fatomes file."""
    natypes = 0
    atomsM = {}
    xyz = []
    lnom = []
    lmass = []
    connects = dict()
    t0 = time.time()
    with open(file, "r") as FATM:
        for line in FATM:

            if noms.match(line):
                m = noms.match(line)
                lnom.append(m.groupdict())

            if masses.match(line):
                m = masses.match(line)
                lmass.append(m.groupdict())

            if "*" == line[0]:
                # ignore lines with the * symbol
                continue

            elif "NbTypesAtomes" in line:
                line = line.split()
                natypes += int(line[1])
                continue

            elif "maille_long" in line:
                line = line.split()
                box = np.array(line[1:4]).astype(np.float64)
                continue

            elif "PositionDesAtomesCart" in line:
                Natoms = int(FATM.readline())
                continue

            elif atoms.match(line):
                m = atoms.match(line)
                xyz.append(m.groupdict())

            elif "Zmatrice" in line:
                N = int(FATM.readline())
                print("N conectivity:", N)
                for _ in range(N):
                    zline = FATM.readline()
                    zline = zline.split()
                    zline = [int(i) for i in zline]
                    connects[zline[0]] = zline[1:]

    atomsM = dict()
    # print("Atoms names:", lnom, len(lnom))
    # print("Atoms masses:", lmass, len(lmass))
    # print(list(range(len(lnom))))

    if len(lmass) == len(lnom):
        # print("Esta bien, son iguales")
        for i in range(len(lnom)):
            atomsM[lnom[i]["nom"]] = np.float64(lmass[i]["mass"])
    else:
        print("ERROR, no; and masses dont similar")
        exit()

    print("Number of atoms in XYZ matrix:", Natoms)
    # print("ATOMS types and Mass [Kg/mol]")
    # print(atomsM)

    print("Box dimensions [angs]:")
    print(box)

    tabXYZ = pd.DataFrame(xyz)

    tabXYZ = tabXYZ.astype({
        "x": np.float64,
        "y": np.float64,
        "z": np.float64
    })

    try:
        tabXYZ["mass"] = tabXYZ["atsb"].apply(lambda x: atomsM[x])
    except KeyError:
        print(atomsM)
        print(tabXYZ.loc[0:26, :])
        print("ERROR")
        exit()

    tf = time.time()
    print(f"FAtomes read: done in {tf-t0:.2f} s")

    return tabXYZ, box, connects


def progress(p):
    """Indicate on a bar the progress of the analysis."""
    bar = int(p * 40 / 100)
    return bar*"=" + (40-bar)*" "


def center_of_mass(coords, masses):
    """Compute the center of mass, the mass weighterd barycenter."""
    return np.sum(coords * masses[:, np.newaxis], axis=0) / masses.sum()


def traj_analysis(ndx_mol, top, traj, box, connectivity, GyrationTensor, b, reset=True):
    """
    Analyze properties during a simulation.

    Parameters
    ----------
    ndx_mol : dict
        Dictionary with the indexes of each molecule to be analyzed.

    top : DataFrame
        File with the system topology.

    traj : list(DataFrame)
        Defines the trajectory of the system in a list of Dataframes.

    box : numpy.array (1x3)
        Vector box.

    connectivity : molcraft.structure.connectivity
        System connectivity.

    GyrationTensor : class
        Class that builds the information.

    b : int
        initial frame.

    reset : boolean
        Write a new file.

    """
    print("Polymer analysis")
    t0 = time.time()

    # Number of frames read
    Nframes = len(traj)
    print(f"Number of frames: {Nframes}")

    if reset:
        out = open("polymers.csv", "w")
        out.write("frame,idx,Natoms,Rg,k2,dmax\n")
        out.close()

    for n_frame, frame in enumerate(traj):
        porcent = n_frame * 100 / Nframes
        print(f"{porcent:6.2f} % |{progress(porcent)}|")
        if n_frame < b:
            continue
        for mol in ndx_mol:
            masses = top.loc[ndx_mol[mol]["index"], "mass"].values
            dfcoord = frame.loc[ndx_mol[mol]["index"], :]

            # Connectivity in the molecule
            connect = connectivity.sub_connect(ndx_mol[mol]["index"])

            # update coordinates
            connect.update_coordinates(dfcoord)

            # remove PBC
            connect.noPBC(box, center=np.zeros(3))

            newdfcoord = connect.get_df()
            coord = newdfcoord.loc[:, ["x", "y", "z"]].values

            G = GyrationTensor(coord, masses, box, pbc=False)

            line = ""
            line += f"{n_frame},"
            line += f"{mol},"
            line += "{},".format(int(ndx_mol[mol]["Natoms"]))
            line += f"{G.iso_w_rg:.2f},"
            line += f"{G.shape_anisotropy:.3f},"
            line += f"{G.max_distance:.2f}"
            line += "\n"
            # print(line)

            with open("polymers.csv", "a") as out:
                out.write(line)

    print(f"{100:6.2f} % |{progress(100)}|")
    tf = time.time()
    print(f"Analysis time: {tf-t0:.2f} s")


def load_data(file, t="LNVT"):
    """
    Load data from Stamp.dat.

    Parameters:
    -----------
    file : str
        Output file from STAMP.

    t : str
        Simulation type: NVT or NPT.

    """
    names = {
        "LNVT": [
            "I",
            "Etot", "Epot", "Epot_intra", "Epot_inter", "Ekin",
            "T", "Tx", "Ty", "Tz",
            "P", "Px", "Py", "Pz",
            "Vx", "Vy", "Vz",
            "D", "cpu"],
        "NPT": [
            "I",
            "Etot", "Epot", "Epot_intra", "Epot_inter", "Ekin",
            "T", "Tx", "Ty", "Tz",
            "P", "Px", "Py", "Pz",
            "Cmvx", "Cmvy", "Cmvz",
            "Lx", "Ly", "Lz",
            "Vx", "Vy", "Vz",
            "Dens",
            "D", "cpu"
        ]}
    data = pd.read_csv(
        file,
        sep=r"\s+",
        header=None,
        names=names[t],
        comment="#"
                      )
    data["Etot"] = data["Etot"] * N_A / 1000  # to kJ/mol
    data["I"] = data["I"] * 1e12  # to ps
    data["P"] = data["P"] * 1e-5  # to bar

    return data


def load_log(file="Stamp.log"):
    """
    Load info from file log Stamp.

    Parameters:
    -----------
    file : str
        Output file from STAMP.

    """
    out_g = []
    out_frame = []
    with open(file, "r") as LOG:
        for line in LOG:
            if out_mean.match(line):
                m = out_mean.match(line)
                out_g.append(m.groupdict())

            if out_xyz.match(line):
                m = out_xyz.match(line)
                out_frame.append(m.groupdict())

    out_g = pd.DataFrame(out_g)
    out_g.drop_duplicates(inplace=True)
    out_g.set_index("frame", inplace=True)

    out_frame = pd.DataFrame(out_frame)
    out_frame.drop_duplicates(inplace=True)

    out_frame["time"] = out_g.loc[out_frame["frame"].values, "time"].unique()
    out_frame = out_frame.astype(
        {"frame": np.int64, "time": np.float64}
    )
    out_frame["time"] = out_frame["time"] * 1e12  # to ps
    return out_frame


def save_system(obj, file="system.chk"):
    """Save the status of an object stamp."""
    with open(file, "wb") as CHK:
        pickle.dump(obj, CHK)

    print("Saved system status.")


def load_system(file):
    """Load the status of an objecto stamp."""
    with open(file, "rb") as CHK:
        system = pickle.load(CHK)

    return system


def save_plot(x, y, name, color="b", xlb="", ylb=""):
    """Save plots."""
    fig, ax = plt.subplots()

    ax.plot(x, y, color=color, alpha=0.8)
    # ax.hist(y, bins=100, orientation='horizontal', alpha=0.4, color=color)

    ax.set_xlabel(xlb)
    ax.set_ylabel(ylb)

    ax.set_title("Mean {:.3f} - std {:.3f}".format(y.mean(), y.std()))

    plt.savefig(f"{name}.png", dpi=300)
    plt.close()


def get_density(XYSs):
    """Return density of system using xyz stamp files."""
    pass


def traj_center_mass(traj, ndx_mol, top, box, connectivity, b=0, reset=True):
    """Return the center of mass of each molecule over time."""
    print("Center of mass analysis")
    t0 = time.time()

    # Number of frames read
    Nframes = len(traj)
    print(f"Number of frames: {Nframes}")

    if reset:
        out = open("mol_cmass.csv", "w")
        out.write("frame,idx,Natoms,x,y,z\n")
        out.close()

    for n_frame, frame in enumerate(traj):
        porcent = n_frame * 100 / Nframes
        print(f"{porcent:6.2f} % |{progress(porcent)}|")
        if n_frame < b:
            continue
        for mol in ndx_mol:
            masses = top.loc[ndx_mol[mol]["index"], "mass"].values
            dfcoord = frame.loc[ndx_mol[mol]["index"], :]

            # Connectivity in the molecule
            connect = connectivity.sub_connect(ndx_mol[mol]["index"])

            # update coordinates
            connect.update_coordinates(dfcoord)

            # remove PBC
            connect.noPBC(box, center=np.zeros(3))

            # extract new coordinates
            newdfcoord = connect.get_df()
            coord = newdfcoord.loc[:, ["x", "y", "z"]].values

            mol_cm = center_of_mass(coord, masses)

            line = ""
            line += f"{n_frame},"
            line += f"{mol},"
            line += "{},".format(int(ndx_mol[mol]["Natoms"]))
            line += f"{mol_cm[0]:.3f},"
            line += f"{mol_cm[1]:.3f},"
            line += f"{mol_cm[2]:.3f}"
            line += "\n"
            # print(line)

            with open("mol_cmass.csv", "a") as out:
                out.write(line)
            
    print(f"{100:6.2f} % |{progress(100)}|")
    tf = time.time()
    print(f"Analysis time: {tf-t0:.2f} s")


def minImagenC(q1, q2, L):
    dq = q2 - q1
    if dq > L * 0.5:
        dq -= L
    
    if dq <= -L * 0.5:
        dq += L
    
    return dq


def get_distances_from(mref, box, file="mol_cmass.csv"):
    # file cm trajectory
    traj_mol_cm = pd.read_csv(file)

    # cm trajectory from ref
    traj_mref = traj_mol_cm[traj_mol_cm["idx"] == 0]

    # cm trajectory from others
    traj_not_mref = traj_mol_cm[traj_mol_cm["idx"] != 0]

    out = open(f"mol_dist_from_{mref}.csv", "w")
    out.write("frame,idx,distance\n")
    out.close()

    for frame in traj_mref["frame"]:
        print("frame", frame)
        mref_xyz = traj_mref[traj_mref["frame"] == frame].loc[:, ["x", "y", "z"]].values[0]
        # print(mref_xyz)
        not_mref_xyz = traj_not_mref[traj_not_mref["frame"] == frame].loc[:, ["idx", "x", "y", "z"]].values
        for mol in not_mref_xyz:
            pol_id = int(mol[0])
            #  print("Polimer id", pol_id)
            mol = mol[1:]
            dist = []
            for i in range(3):
                ndist = minImagenC(mref_xyz[i], mol[i], box[i])
                # ndist = mol[i] - mref_xyz[i]
                dist.append(ndist)
            dist = np.linalg.norm(dist)
            #print("distance", dist)
            line = ""
            line += f"{frame},"
            line += f"{pol_id},"
            line += f"{dist:.3f}"
            line += "\n"
            
            with open(f"mol_dist_from_{mref}.csv", "a") as out:
                out.write(line)


def translate_to(coord, center, box):
    """Translate coordinates using a reference center."""
    newcoord = np.zeros(coord.shape)
    for i, atom in enumerate(coord):
        for j, q in enumerate(atom):
            newcoord[i, j] = minImagenC(center[j], q, box[j])
    
    return newcoord


def change_atsb(x):
    """Change the FAtomes atom types to atoms from XYZ files."""
    if x in ["ca", "cb", "CT", "CM"]:
        return "C"
    elif x in ["ha", "ho", "HT", "HM"]:
        return "H"
    elif x in ["nf", "ne"]:
        return "N"
    elif x in ["oh"]:
        return "O"


def gen_centered_traj(mol, mol_dist, c_mass, rcutoff=1.5, ref=0, out_folder="centered_traj"):
    """Generate a trajectory of the system using a reference center."""
    traj = mol.traj
    traj_resid_in_r = mol_dist[mol_dist["distance"] <= rcutoff]
    traj_center_ref = c_mass[c_mass["idx"] == ref].loc[:, ["x", "y", "z"]].values
    
    atoms_per_mol = mol.atoms_per_mol
    connectivity = mol.connectivity
    box = mol.box
    
    # Output folder
    try:
        os.mkdir(out_folder)
    except FileExistsError:
        print("The output foler was already created")
        
    for frame, coord in enumerate(traj):
        name = "centered_mol_%04d" % frame
        
        resid = [ref] + list(traj_resid_in_r["idx"][traj_resid_in_r["frame"] == frame].values)
        center = traj_center_ref[frame]
        
        atoms_ndx = []
        ncoords = []
        for res in resid:
            atoms = atoms_per_mol[res]["index"]
            mol_conn = connectivity.sub_connect(atoms)
            df = coord.loc[atoms, :]
            # Translate to a center of reference
            df.loc[:, ["x", "y", "z"]] = translate_to(df.loc[:, ["x", "y", "z"]].values, center, box)
            # update coordinates
            mol_conn.update_coordinates(df)
            # remove PBC
            mol_conn.noPBC(box, center=np.zeros(3))
            # Reset index and symbols, and add mass
            mol_conn = mol_conn.reset_nodes()
            mol_conn.simple_at_symbols()

            # Search and add hydrogen to vacant atoms
            mol_conn.add_hydrogen(box, type_add="terminal")
            new_mol_xyz = mol_conn.get_df()
            ncoords.append(new_mol_xyz)
            # ndf = mol_conn.get_df()
            # connects.update_coordinates(ndf)
            # atoms_ndx += atoms
        ####
        # sys_conn = connects.sub_connect(atoms_ndx)
        # new df
        # ndf = sys_conn.get_df()
        # ndf["atsb"] = ndf["atsb"].apply(change_atsb).values.astype(str)
        ncoords = pd.concat(ncoords, ignore_index=True)
        
        save_xyz(ncoords, name=f"{out_folder}/{name}")


def mol_traj_analysis(index, mol_ndx, connectivity, traj, box):
    """Analyze trajectory of a particular molecule."""
    i = 0
    for xyz in traj:
        name = "mol_%d_%005d" % (index, i)

        mol_xyz = xyz.loc[mol_ndx["index"], :]
        mol_conn = connectivity.sub_connect(mol_ndx["index"])
        # update coordinates
        mol_conn.update_coordinates(mol_xyz)

        # remove PBC
        mol_conn.noPBC(box, center=np.zeros(3))

        # Reset index and symbols, and add mass
        mol_conn = mol_conn.reset_nodes()
        mol_conn.simple_at_symbols(add_mass=True)

        # Search and add hydrogen to vacant atoms
        mol_conn.add_hydrogen(box, type_add="terminal")
        new_mol_xyz = mol_conn.get_df()

        cm = center_of_mass(
            new_mol_xyz.loc[:, ["x", "y", "z"]].values,
            new_mol_xyz.loc[:, "mass"].values
        )

        new_mol_xyz["x"] -= cm[0]
        new_mol_xyz["y"] -= cm[1]
        new_mol_xyz["z"] -= cm[2]

        save_xyz(new_mol_xyz, name=name)
        i += 1

    os.system(f"cat mol_{index}_0* > mol_{index}_traj.xyz")
    os.system(f"rm mol_{index}_0*")
    print(f"Saved trajectory mol {index} in mol_{index}_traj.xyz")


def rdf_from_dist(df, box, rmin=0.0, rmax=6.0, binwidth=0.002):
    """Return rdf data and binned function."""
    def binned_distance(x):
        bins = np.arange(rmin, rmax, binwidth)
        index = np.digitize(x, bins)
        try:
            return bins[index]
        except IndexError:
            return np.NaN
        
    df["bin"] = df["distance"].apply(binned_distance)

    frames = df["frame"].unique()
    n_frames = len(frames)
    n_mol = df["distance"].count() / n_frames

    # Box in nanometers
    vol_per_com = box[0] * box[1] * box[2] / n_mol
    
    rdf = df.groupby("bin").count()
    rdf.reset_index(inplace=True)
    
    rdf["vshell"] = 4 * np.pi * ((binwidth + rdf["bin"])**3 - rdf["bin"]**3) / 3
    
    rdf["gr"] = rdf["distance"] * vol_per_com / rdf["vshell"] / n_frames
    rdf["weihts"] = vol_per_com / rdf["vshell"] / n_frames
    
    return rdf, binned_distance


""" PLOTS FUNCTIONS """


confIsomer = {
        "cis": {"color": "#699deb", "lim": [-40, 40]},
        "trans": {"color": "#734f96", "lim": [-190, 190]}
    }


def thermo_plots(obj):
    """Thermodynamic Analysis."""
    fig, axs = plt.subplots(ncols=3, figsize=(12,4))
    (ax1, ax2, ax3) = axs

    sns.lineplot(data=obj.data, x="I", y="T", color="red", ax=ax1, alpha=0.8)
    ax1.set_ylabel("Temperature (K)")
    ax1.set_xlabel("time (ps)")
    ax1.set_title(
        r"$\bar T =$ {:.2f} $\pm$ {:.2f} K".format(
            obj.data["T"].mean(),
            obj.data["T"].std())
        )

    sns.lineplot(data=obj.data, x="I", y="P", color="purple", ax=ax2, alpha=0.8)
    ax2.set_ylabel("Pressure (bar)")
    ax2.set_xlabel("time (ps)")
    ax2.set_title(
        r"$\bar P =$ {:.2f} $\pm$ {:.2f} bar".format(
            obj.data["P"].mean(),
            obj.data["P"].std())
        )

    sns.lineplot(data=obj.data, x="I", y="Etot", color="green", ax=ax3, alpha=0.8)
    ax3.set_ylabel("Total Energy (kJ/mol)")
    ax3.set_xlabel("time (ps)")
    ax3.set_title(
        r"$\bar Etot =$ {:.2f} $\pm$ {:.2f} kJ/mol".format(
            obj.data["Etot"].mean(),
            obj.data["Etot"].std())
        )

    return fig, axs


def dih_plots(data, isomer):
    """Dihedrals Analysis."""
    fig, axs = plt.subplots(ncols=3, figsize=(12, 4))

    (ax1, ax2, ax3) = axs
    ylim = confIsomer[isomer]["lim"]

    sns.regplot(
        data=data,
        x="t", 
        y="torsion",
        ax=ax1,
        label=isomer,
        scatter_kws={"alpha": 0.6},
        line_kws={"color": "k"},
        color=confIsomer[isomer]["color"]
    )
    ax1.set_title("per time")
    ax1.set_ylabel("angle (degree)")
    ax1.set_xlabel("time (ps)")
    ax1.set_ylim(ylim)
    ax1.legend()

    sns.histplot(
        data=data,
        y="torsion",
        ax=ax2,
        label=isomer,
        binwidth=2,
        color=confIsomer[isomer]["color"]
    )
    ax2.set_title("histogram")
    ax2.set_ylabel("angle (degree)")
    ax2.set_xlabel("count")
    ax2.set_ylim(ylim)
    ax2.legend()

    sns.histplot(
        data=data,
        y="abs",
        ax=ax3,
        label=isomer,
        binwidth=2,
        color=confIsomer[isomer]["color"]
    )
    ax3.set_title("histogram (module)")
    ax3.set_ylabel("angle (degree)")
    ax3.set_xlabel("count")
    ax3.legend()

    box = {
        "facecolor": "0.85",
        "edgecolor": "k",
        "boxstyle": "round"
    }

    ax2.text(0.5, 0.2, r"{} - dih $=$ {:.2f} $\pm$ {:.2f} degre".format(
        isomer, data["torsion"].mean(),
        data["torsion"].std()
        ),
        transform=ax2.transAxes,
        bbox=box,
        ha="center")

    ax3.text(0.5, 0.2, r"{} - dih $=$ {:.2f} $\pm$ {:.2f} degre".format(
        isomer, data["abs"].mean(),
        data["abs"].std()
        ),
        transform=ax3.transAxes,
        bbox=box,
        ha="center")

    return fig, axs


def poly_plots_general(data):
    """Polymers analysis."""
    fig, axs = plt.subplots(ncols=3, figsize=(12, 4))

    sns.histplot(
        data=data,
        x="Rg",
        ax=axs[0],
        kde=True,
        color="#2a90a6",
        binwidth=0.5,
        stat="count",
        weights=1/data["frame"].max(),
        alpha=0.5
    )
    axs[0].set_xlabel("Radius of gyration ($\AA$)")
    axs[0].set_xlim(7, 25)

    sns.histplot(
        data=data,
        x="dmax",
        ax=axs[1],
        kde=True,
        color="#5b557b",
        binwidth=2.,
        stat="count",
        weights=1/data["frame"].max(),
        alpha=0.5
    )
    axs[1].set_xlabel("Max. distance ($\AA$)")
    axs[1].set_xlim(20, 90)

    sns.histplot(
        data=data,
        x="k2",
        ax=axs[2],
        kde=True,
        color="#fea6ad",
        binwidth=0.05,
        stat="count",
        weights=1/data["frame"].max()
    )
    axs[2].set_xlabel("Shape anisotropy")
    axs[2].set_xlim(0, 1)

    return fig, axs


def poly_plots_temporal(data):
    """Analysis of polymers in the time."""
    label = list(data["time"].unique())

    fig, axs = plt.subplots(nrows=len(label), ncols=3, figsize=(12, 2*len(label)))
    fig.subplots_adjust(hspace=0.1, wspace=0.2)

    box = {
        "facecolor": "0.85",
        "edgecolor": "k",
        "boxstyle": "round"
    }

    Analysis = {
        "Rg": {"color": "#2a90a6", "binw": 0.5, "xlim": [7, 22], "title": "Radius of gyration ($\AA$)"},
        "dmax": {"color": "#5b557b", "binw": 2.0, "xlim": [20, 80], "title": "Max. distance ($\AA$)"},
        "k2": {"color": "#fea6ad", "binw": 0.05, "xlim": [0, 1], "title": "Shape anisotropy"}
    }

    for i, t in enumerate(label):
        subdata = data[data["time"] == t]
        for j, anl in enumerate(Analysis):
            sns.histplot(
                data=subdata,
                x=anl,
                ax=axs[i, j],
                kde=True,
                color=Analysis[anl]["color"],
                binwidth=Analysis[anl]["binw"],
                stat="density",
                alpha=0.5
            )
            axs[i, j].set_xlim(Analysis[anl]["xlim"])
            axs[i, j].set_xlabel(Analysis[anl]["title"])
            axs[i, j].axvline(x=subdata[anl].mean(), color="k", ls="--", lw=2)

            if i != len(label)-1:
                axs[i, j].get_xaxis().set_visible(False)

        axs[i, 0].text(
            0.8, 0.8,
            "{}".format(t),
            transform=axs[i, 0].transAxes,
            bbox=box,
            ha="center"
        )

    return fig, axs


def dist_plots_general(data_prop):
    """Distances analysis."""
    fig, axs = plt.subplots(ncols=3, figsize=(12, 4))
    (ax1, ax2, ax3) = axs

    sns.histplot(
        data=data_prop,
        x="distance",
        binwidth=.1,
        kde=True,
        color="#9c89e8",
        stat="density",
        ax=ax1,
        cbar_kws={"alpha": 0.5}
    )
    ax1.axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax1.axvline(x=2.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax1.axvline(x=3.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax1.set_xlabel("distance (nm)")
    ax1.set_xlim(0, 5)

    sns.histplot(
        data=data_prop,
        x="distance",
        y="Rg",
        binwidth=[0.1, 0.5],
        ax=ax2, color="#537f6b"
        )
    ax2.axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax2.axvline(x=2.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax2.axvline(x=3.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax2.axhline(y=data_prop["Rg"].mean(), ls="--", color="#537f6b", lw=2.0, alpha=1.0)
    ax2.set_xlabel("distance (nm)")
    ax2.set_ylabel("Radius of gyration ($\AA$)")
    ax2.set_xlim(0, 5)
    ax2.set_ylim(7, 25)

    sns.histplot(data=data_prop, x="distance", y="k2", binwidth=[0.1, 0.05], ax=ax3, color="#5d3954")
    ax3.axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax3.axvline(x=2.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax3.axvline(x=3.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax3.axhline(y=data_prop["k2"].mean(), ls="--", color="#5d3954", lw=2.0, alpha=1.0)
    ax3.set_xlabel("distance (nm)")
    ax3.set_ylabel("Shape anisotropy")
    ax3.set_xlim(0, 5)
    ax3.set_ylim(0, 1)

    return fig, axs


def dist_plots_temporal(data):
    """Distances analysis in time."""
    label = list(data["time"].unique())
    
    fig, axs = plt.subplots(nrows=len(label), ncols=3, figsize=(12, 2*len(label)))
    fig.subplots_adjust(hspace=0.1, wspace=0.2)
    
    box = {
        "facecolor": "0.85",
        "edgecolor": "k",
        "boxstyle": "round"
    }
    
    Analysis = {
        "Rg": {"color": "#2a90a6", "binw": 0.5, "xlim": [7, 22], "title": "Radius of gyration ($\AA$)"},
        "dmax": {"color": "#5b557b", "binw": 2.0, "xlim": [20, 80], "title": "Max. distance ($\AA$)"},
        "k2": {"color": "#fea6ad", "binw": 0.05, "xlim": [0, 1], "title": "Shape anisotropy"}
    }
    
    for i, t in enumerate(label):
        subdata = data[data["time"] == t]
        for j, anl in enumerate(Analysis):
            if j == 0:
                sns.histplot(
                    data=subdata,
                    x="distance",
                    binwidth=.1,
                    kde=True,
                    color="#9c89e8",
                    stat="density",
                    ax=axs[i, j],
                    cbar_kws={"alpha": 0.5}
                )
                axs[i, j].axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
                #ax1.axvline(x=2.5, ls="--", color="k", lw=2.0, alpha=0.7)
                #ax1.axvline(x=3.5, ls="--", color="k", lw=2.0, alpha=0.7)
                axs[i, j].set_xlabel("distance (nm)")
                axs[i, j].set_xlim(0, 5)
                
            elif j == 1:
                sns.histplot(
                    data=subdata,
                    x="distance",
                    y="Rg",
                    binwidth=[0.1, 0.5],
                    ax=axs[i, j],
                    color="#537f6b"
                )
                axs[i, j].axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
                axs[i, j].axhline(y=subdata["Rg"].mean(), ls="--", color="#537f6b", lw=2.0, alpha=1.0)
                axs[i, j].set_xlabel("distance (nm)")
                axs[i, j].set_ylabel("Rg ($\AA$)")
                axs[i, j].set_xlim(0, 5)
                axs[i, j].set_ylim(7, 25)
                
            elif j == 2:
                sns.histplot(
                    data=subdata,
                    x="distance",
                    y="k2",
                    binwidth=[0.1, 0.05],
                    ax=axs[i, j],
                    color="#5d3954"
                )
                axs[i, j].axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
                axs[i, j].axhline(y=subdata["k2"].mean(), ls="--", color="#5d3954", lw=2.0, alpha=1.0)
                axs[i, j].set_xlabel("distance (nm)")
                axs[i, j].set_ylabel("Shape anisotropy")
                axs[i, j].set_xlim(0, 5)
                axs[i, j].set_ylim(0, 1)

            if i != len(label)-1:
                axs[i, j].get_xaxis().set_visible(False)
                
        axs[i, 0].text(
            0.85, 0.8,
            "{}".format(t),
            transform=axs[i, 0].transAxes,
            bbox=box,
            ha="center"
        )
    
    return fig, axs


def rdf_plots_general(data_prop):
    """Distance analysis using rdf normalization."""
    fig, axs = plt.subplots(ncols=3, figsize=(12, 4))
    
    (ax1, ax2, ax3) = axs
    
    sns.lineplot(
        data=data_prop,
        x="distance",
        y="gr",
        ax=ax1,
        color="#9c89e8"
    )
    ax1.axhline(y=1.0, ls="--", color="gray")
    ax1.axvline(x=1.7, ls="--", color="black")
    ax1.set_xlabel("r (nm)")
    ax1.set_ylabel("g (r)")
    ax1.set_xlim(0, 3)
    
    sns.histplot(
        data=data_prop,
        x="distance",
        y="Rg",
        binwidth=[0.1, 0.5],
        weights="w",
        ax=ax2,
        color="#537f6b"
    )
    ax2.set_xlim(0, 3)
    ax2.set_ylim(7, 25)
    ax2.set_xlabel("r (nm)")
    ax2.set_ylabel("Radius of gyration ($\AA$)")
    
    ax2.axhline(y=data_prop["Rg"].mean(), ls="--", color="#537f6b", lw=2.0, alpha=1.0)
    ax2.axvline(x=1.7, ls="--", color="black")
    
    sns.histplot(
        data=data_prop,
        x="distance",
        y="k2",
        binwidth=[0.1, 0.05],
        weights="w",
        ax=ax3,
        color="#5d3954"
    )
    ax3.set_xlim(0, 3)
    ax3.set_ylim(0, 1)
    ax3.set_xlabel("r (nm)")
    ax3.set_ylabel("Shape anisotropy")
    ax3.axhline(y=data_prop["k2"].mean(), ls="--", color="#5d3954", lw=2.0, alpha=1.0)
    ax3.axvline(x=1.7, ls="--", color="black")

    return fig, axs


def rdf_plots_temporal(data, L):
    """Distances rdf analysis in time."""
    label = list(data["time"].unique())
    
    fig, axs = plt.subplots(nrows=len(label), ncols=3, figsize=(12, 2*len(label)))
    fig.subplots_adjust(hspace=0.1, wspace=0.2)
    
    box = {
        "facecolor": "0.85",
        "edgecolor": "k",
        "boxstyle": "round"
    }
    
    Analysis = {
        "Rg": {"color": "#2a90a6", "binw": 0.5, "xlim": [7, 22], "title": "Radius of gyration ($\AA$)"},
        "dmax": {"color": "#5b557b", "binw": 2.0, "xlim": [20, 80], "title": "Max. distance ($\AA$)"},
        "k2": {"color": "#fea6ad", "binw": 0.05, "xlim": [0, 1], "title": "Shape anisotropy"}
    }

    for i, t in enumerate(label):
        subdata = data[data["time"] == t].copy()
        rdf, binned_distance = rdf_from_dist(subdata.copy(), L * 0.1, rmax=3.1, binwidth=0.01)
        rdf.set_index("bin", inplace=True)
        subdata.loc[:, "distance"] = subdata["distance"].apply(binned_distance)
        subdata.dropna(axis=0, inplace=True)

        subdata.loc[:, "gr"] = subdata["distance"].apply(lambda x: rdf.loc[x, "gr"])
        subdata.loc[:, "w"] = subdata["distance"].apply(lambda x: rdf.loc[x, "weihts"])

        for j, anl in enumerate(Analysis):
            if j == 0:
                """RDF"""
                sns.lineplot(
                    data=subdata,
                    x="distance",
                    y="gr",
                    ax=axs[i, j],
                    color="#9c89e8"
                )
                axs[i, j].axhline(y=1.0, ls="--", color="gray")
                axs[i, j].axvline(x=1.7, ls="--", color="black")
                axs[i, j].set_xlabel("r (nm)")
                axs[i, j].set_ylabel("g (r)")
                axs[i, j].set_xlim(0, 3)

            elif j == 1:
                """Rg vs distance"""
                sns.histplot(
                    data=subdata,
                    x="distance",
                    y="Rg",
                    binwidth=[0.1, 0.5],
                    weights="w",
                    ax=axs[i, j],
                    color="#537f6b"
                )
                axs[i, j].set_xlim(0, 3)
                axs[i, j].set_ylim(7, 25)
                axs[i, j].set_xlabel("r (nm)")
                axs[i, j].set_ylabel("Radius of gyration ($\AA$)")
    
                axs[i, j].axhline(y=subdata["Rg"].mean(), ls="--", color="#537f6b", lw=2.0, alpha=1.0)
                axs[i, j].axvline(x=1.7, ls="--", color="black")

            elif j == 2:
                """shape anisotrope"""
                sns.histplot(
                    data=subdata,
                    x="distance",
                    y="k2",
                    binwidth=[0.1, 0.05],
                    weights="w",
                    ax=axs[i, j],
                    color="#5d3954"
                )
                axs[i, j].set_xlim(0, 3)
                axs[i, j].set_ylim(0, 1)
                axs[i, j].set_xlabel("r (nm)")
                axs[i, j].set_ylabel("Shape anisotropy")
                axs[i, j].axhline(y=subdata["k2"].mean(), ls="--", color="#5d3954", lw=2.0, alpha=1.0)
                axs[i, j].axvline(x=1.7, ls="--", color="black")

            if i != len(label)-1:
                axs[i, j].get_xaxis().set_visible(False)

        axs[i, 0].text(
            0.85, 0.8,
            "{}".format(t),
            transform=axs[i, 0].transAxes,
            bbox=box,
            ha="center"
        )

    return fig, axs


def plots_mean_per_time(data):
    """Means per time groups."""
    fig, axs = plt.subplots(ncols=3, figsize=(12, 4))

    box = {
        "facecolor": "0.85",
        "edgecolor": "k",
        "boxstyle": "round"
    }

    (ax1, ax2, ax3) = axs

    ax1.errorbar(
        data["t"], data["Rg"]["mean"],
        yerr=data["Rg"]["std"], fmt="o", capsize=4,
        color="black", ecolor="#2a90a6"
    )
    regress = linregress(data["t"], y=data["Rg"]["mean"])
    ax1.plot(data["t"], data["t"] * regress.slope + regress.intercept)
    ax1.set_ylim(7, 25)
    ax1.set_xlabel("time (ps)")
    ax1.set_ylabel("Radius of gyration ($\AA$)")

    ax1.text(
        0.5, 0.8,
        "{:.2f}x+{:.2f} - R2 = {:.3f}".format(regress.slope, regress.intercept, regress.rvalue**2),
        transform=ax1.transAxes,
        bbox=box,
        ha="center"
    )

    ax2.errorbar(
        data["t"], data["dmax"]["mean"],
        yerr=data["dmax"]["std"], fmt="o", capsize=4,
        color="black", ecolor="#5b557b"
    )
    regress = linregress(data["t"], y=data["dmax"]["mean"])
    ax2.plot(data["t"], data["t"] * regress.slope + regress.intercept)
    ax2.set_ylim(20, 90)
    ax2.set_xlabel("time (ps)")
    ax2.set_ylabel("Max. distance ($\AA$)")

    ax2.text(
        0.5, 0.8,
        "{:.2f}x+{:.2f} - R2 = {:.3f}".format(regress.slope, regress.intercept, regress.rvalue**2),
        transform=ax2.transAxes,
        bbox=box,
        ha="center"
    )

    ax3.errorbar(
        data["t"], data["k2"]["mean"],
        yerr=data["k2"]["std"], fmt="o", capsize=4,
        color="black", ecolor="#5b557b"
    )
    regress = linregress(data["t"], y=data["k2"]["mean"])
    ax3.plot(data["t"], data["t"] * regress.slope + regress.intercept)
    ax3.set_ylim(0, 1)
    ax3.set_xlabel("time (ps)")
    ax3.set_ylabel("Shape anisotropy")

    ax3.text(
        0.5, 0.8,
        "{:.2f}x+{:.2f} - R2 = {:.3f}".format(regress.slope, regress.intercept, regress.rvalue**2),
        transform=ax3.transAxes,
        bbox=box,
        ha="center"
    )

    return fig, axs


def GenPlots(
    home, pc,  step, replica, isomer, name, out, t_min=500, t_max=2500,
    t_step=500, thermo=True, dihedrals=True, polymer=True, distances=True,
    rdfs=True, means_t=True, return_data=False
):
    """Graph and save all analyses."""
    sys = load_system(f"{home}/{pc}_procedure/{step}_prod_{replica}/system.chk")
    lims = np.arange(t_min, t_max + t_step, t_step)

    def binned_time(x):
        ind = np.digitize(x, lims)
        try:
            return f"{lims[ind]}ps"
        except IndexError:
            return np.NaN

    """Termodynamics."""
    if thermo:
        fig, axs = thermo_plots(sys)
        fig.suptitle(
            f"Thermodynamic properties - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_thermo_s{step}r{replica}.png", dpi=300)

    """Dihedrals."""
    if dihedrals:
        sys_dih = pd.read_csv(f"{home}/{pc}_procedure/{step}_prod_{replica}/dihedrals.dat", sep="\s+", header=None, index_col=0, names=["torsion"])
        # print(sys.time_per_frame)
        # print(sys_dih)
        # exit()
        # sys_dih["t"] = sys.data["I"][::10].values[1:]
        sys_dih["t"] = sys.time_per_frame["time"]
        sys_dih["abs"] = sys_dih["torsion"].abs()

        fig, axs = dih_plots(sys_dih, isomer)
        fig.suptitle(f"Torsion angles in polymer matrix - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_dihs_s{step}r{replica}.png", dpi=300)

    """Polymers."""
    sys_pol = pd.read_csv(f"{home}/{pc}_procedure/{step}_prod_{replica}/polymers.csv")
    # frame_to_time = dict(enumerate(sys.data["I"][::10].values[1:]))
    frame_to_time = {i: sys.time_per_frame.loc[i, "time"] for i in sys.time_per_frame.index}
    sys_pol["time"] = sys_pol["frame"].apply(lambda x: frame_to_time[x])
    pol_c = sys_pol[sys_pol["idx"] != 0].copy()
    pol_c["time"] = pol_c["time"].apply(binned_time)
    pol_t = pol_c.dropna(axis=0)

    if polymer:
        fig, axs = poly_plots_general(pol_c)
        fig.suptitle(f"Global analysis of the polymeric matrix - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_poly_g_s{step}r{replica}.png", dpi=300)

        """Polymer by time."""
        fig, axs = poly_plots_temporal(pol_t)
        fig.suptitle(f"Polymeric analysis by time period - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_poly_t_s{step}r{replica}.png", dpi=300)

    """Distances."""
    sys_dist = pd.read_csv(f"{home}/{pc}_procedure/{step}_prod_{replica}/mol_dist_from_0.csv")
    sys_dist["distance"] *= 0.1

    dprop = pd.DataFrame({
        "distance": sys_dist["distance"].values,
        "Rg": pol_c["Rg"].values,
        "k2": pol_c["k2"].values,
        "dmax": pol_c["dmax"].values,
        "time": pol_c["time"].values
    })

    dprop.dropna(axis=0, inplace=True)
    if distances:
        fig, axs = dist_plots_general(dprop)
        fig.suptitle(f"Global analysis of the distances from the PC - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_dist_g_s{step}r{replica}.png", dpi=300)

        # Distance by time
        fig, axs = dist_plots_temporal(dprop)
        fig.suptitle(f"Distances analysis by time period - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_dist_t_s{step}r{replica}.png", dpi=300)

    """ RDF distances general."""
    dprop = pd.DataFrame({
        "distance": sys_dist["distance"].values,
        "Rg": pol_c["Rg"].values,
        "k2": pol_c["k2"].values,
        "dmax": pol_c["dmax"].values,
        "time": pol_c["time"].values,
        "frame": pol_c["frame"].values
    })

    rdf, binned_distance = rdf_from_dist(sys_dist, sys.box * 0.1, rmax=3.1, binwidth=0.01)
    rdf.set_index("bin", inplace=True)
    dprop["distance"] = dprop["distance"].apply(binned_distance)
    dprop.dropna(axis=0, inplace=True)
    dprop["gr"] = dprop["distance"].apply(lambda x: rdf.loc[x, "gr"])
    dprop["w"] = dprop["distance"].apply(lambda x: rdf.loc[x, "weihts"])

    if rdfs:
        fig, axs = rdf_plots_general(dprop)
        fig.suptitle(f"RDF analysis from the PC - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_rdf_g_s{step}r{replica}.png", dpi=300)

    sys_dist["time"] = sys_dist["frame"].apply(lambda x: frame_to_time[x])
    sys_dist["time"] = sys_dist["time"].apply(binned_time)
    sys_dist.dropna(axis=0, inplace=True)

    if rdfs:
        fig, axs = rdf_plots_temporal(dprop, sys.box)
        fig.suptitle(f"RDF analysis of the distances by time period - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_rdf_t_s{step}r{replica}.png", dpi=300)

    aggregation = {
        "Rg": ["mean", "std"],
        "k2": ["mean", "std"],
        "dmax": ["mean", "std"]
    }

    dprop_resume = dprop.groupby("time").agg(aggregation)
    dprop_resume["t"] = [int(i.replace("ps", "")) for i in dprop_resume.index]

    if means_t:
        fig, axs = plots_mean_per_time(dprop_resume)
        fig.suptitle(f"Mean analysis of polymer - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_means_t_s{step}r{replica}.png", dpi=300)

    if return_data:
        return dprop
