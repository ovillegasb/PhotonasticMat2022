"""Module dedicated to the analysis of trajectories generated by STAMP."""

import re
import time
import numpy as np
import pandas as pd
from scipy.constants import N_A
import pickle
import matplotlib.pyplot as plt
import seaborn as sns
import os
from molcraft.structure import save_xyz
from scipy.stats import linregress
from scipy.spatial.distance import cdist
from molcraft.clusters import GyrationTensor


""" Regular expression that extracts matrix XYZ """
atoms = re.compile(r"""
        ^\s*
        (?P<atsb>[A-Za-z]+\d?\d?)\s+      # Atom name.
        (?P<x>[+-]?\d+\.\d+\w?[+-]?\d*)\s+           # Orthogonal coordinates for X.
        (?P<y>[+-]?\d+\.\d+\w?[+-]?\d*)\s+           # Orthogonal coordinates for Y.
        (?P<z>[+-]?\d+\.\d+\w?[+-]?\d*)\s+           # Orthogonal coordinates for Z.
        """, re.X)

""" Regular expression for .log """
out_mean = re.compile(r"""
    \s*
    (?P<frame>\d+)\s                      # Frame
    -\sCPU=(?P<cpu>\d+\.\w+[+-]?\d+)\s
    .+\s
    t=(?P<time>\d+\.\w+[+-]?\d+)
    """, re.X)

out_xyz = re.compile(r"""
    ^\s+[\*]+\sIteration\s
    (?P<frame>\d+)\s
    -\sSortie\sXYZ
    """, re.X)

""" Regular expression for FAtomes """

noms = re.compile(r"""
    nom\s+(?P<nom>\w+)
    """, re.X)

masses = re.compile(r"""
    masse\s+(?P<mass>\d+\.\w+[+-]?\d+)
    """, re.X)

charges = re.compile(r"""
    charge\s+(?P<charge>[+-]?\d+\.\d+)
    """, re.X)


def decoTime(func):
    def elapsed_time(*args, **kwargs):
        """Print the elapsed time in the use of the function."""
        t0 = time.time()
        func(*args, **kwargs)
        tf = time.time()
        print(f"done in {tf-t0:.3f} s")

    return elapsed_time


def read_fatomes(file):
    """Read Fatomes file."""
    t0 = time.time()
    print("Reading fatomes file", end=" - ")
    natypes = 0
    atomsM = {}
    xyz = []
    lnom = []
    lmass = []
    lcharges = []
    lcharge_mod = []
    connects = dict()
    with open(file, "r") as FATM:
        nom = ""
        for line in FATM:
            if noms.match(line):
                nom = ""
                m = noms.match(line)
                lnom.append(m.groupdict())
                nom += m.groupdict()["nom"]

            if masses.match(line):
                m = masses.match(line)
                lmass.append(m.groupdict())

            if charges.match(line):
                m = charges.match(line)
                lcharges.append((nom, float(m.groupdict()["charge"])))
                nom = ""

            if "*" == line[0]:
                # ignore lines with the * symbol
                continue

            elif "NbTypesAtomes" in line:
                line = line.split()
                natypes += int(line[1])
                continue

            elif "maille_long" in line:
                line = line.split()
                box = np.array(line[1:4]).astype(np.float64)
                continue

            elif atoms.match(line):
                m = atoms.match(line)
                xyz.append(m.groupdict())

            elif "Zmatrice" in line:
                N = int(FATM.readline())
                # print("N conectivity:", N)
                for _ in range(N):
                    zline = FATM.readline()
                    zline = zline.split()
                    zline = [int(i) for i in zline]
                    connects[zline[0]] = zline[1:]

            elif "ModificationChargeDesAtomes" in line:
                N = int(FATM.readline())
                for _ in range(N):
                    chline = FATM.readline()
                    chline = chline.split()
                    lcharge_mod.append({"idx": int(chline[0]), "charge": float(chline[1])})
    
    lcharges = {key: charge for (key, charge) in lcharges}
    def from_lcharges(x):
        try:
            return lcharges[x]
        except KeyError:
            return 0.0

    lcharge_mod = pd.DataFrame(lcharge_mod)
    atomsM = dict()

    if len(lmass) == len(lnom):
        for i in range(len(lnom)):
            atomsM[lnom[i]["nom"]] = np.float64(lmass[i]["mass"])
            if lnom[i]["nom"][0].upper() == "H":
                atomsM[lnom[i]["nom"]] = np.float64(1.008e-03)

    else:
        print("\nERROR, no; and masses dont similar")
        exit()

    tabXYZ = pd.DataFrame(xyz)

    tabXYZ = tabXYZ.astype({
        "x": np.float64,
        "y": np.float64,
        "z": np.float64
    })

    try:
        tabXYZ["mass"] = tabXYZ["atsb"].apply(lambda x: atomsM[x])
    except KeyError:
        print("")
        print(atomsM)
        print(tabXYZ.loc[0:26, :])
        print("ERROR")
        exit()

    tabXYZ["charge"] = tabXYZ["atsb"].apply(from_lcharges)

    for i in lcharge_mod.index:
        tabXYZ.loc[lcharge_mod.loc[i, "idx"], "charge"] = lcharge_mod.loc[i, "charge"]

    tf = time.time()
    print(f"done in {tf-t0:.2f} s")

    return tabXYZ, box, connects


def progress(p):
    """Indicate on a bar the progress of the analysis."""
    bar = int(p * 40 / 100)
    return bar*"=" + (40-bar)*" "


def center_of_mass(coords, masses):
    """Compute the center of mass, the mass weighterd barycenter."""
    return np.sum(coords * masses[:, np.newaxis], axis=0) / masses.sum()


def traj_analysis(ndx_mol, top, traj, box, connectivity, b=0, reset=True):
    """
    Analyze properties during a simulation.

    Parameters
    ----------
    ndx_mol : dict
        Dictionary with the indexes of each molecule to be analyzed.

    top : DataFrame
        File with the system topology.

    traj : list(DataFrame)
        Defines the trajectory of the system in a list of Dataframes.

    box : numpy.array (1x3)
        Vector box.

    connectivity : molcraft.structure.connectivity
        System connectivity.

    b : int
        initial frame.

    reset : boolean
        Write a new file.

    """
    print("Trajectory analysis")
    t0 = time.time()

    # Number of frames read
    Nframes = len(traj)
    print(f"Number of frames: {Nframes}")

    if reset:
        out = open("molprop.csv", "w")
        out.write("frame,idx,Natoms,Rg,k2,dmax,x,y,z\n")
        out.close()

    for n_frame, frame in enumerate(traj):
        porcent = n_frame * 100 / Nframes
        print(f"{porcent:6.2f} % |{progress(porcent)}|")
        if n_frame < b:
            continue
        for mol in ndx_mol:
            if len(ndx_mol[mol]["index"]) == 1:
                continue
            masses = top.loc[ndx_mol[mol]["index"], "mass"].values
            dfcoord = frame.loc[ndx_mol[mol]["index"], :]

            # Connectivity in the molecule
            connect = connectivity.sub_connect(ndx_mol[mol]["index"])

            # update coordinates
            connect.update_coordinates(dfcoord)

            # remove PBC
            connect.noPBC(box, center=np.zeros(3))

            newdfcoord = connect.get_df()
            coord = newdfcoord.loc[:, ["x", "y", "z"]].values

            G = GyrationTensor(coord, masses, box, pbc=False)

            line = ""
            line += f"{n_frame},"
            line += f"{mol},"
            line += "{},".format(int(ndx_mol[mol]["Natoms"]))
            line += f"{G.iso_w_rg:.2f},"
            line += f"{G.shape_anisotropy:.3f},"
            line += f"{G.max_distance:.2f},"

            # Center of mass
            mol_cm = center_of_mass(coord, masses)
            line += f"{mol_cm[0]:.3f},"
            line += f"{mol_cm[1]:.3f},"
            line += f"{mol_cm[2]:.3f}"
            line += "\n"

            with open("molprop.csv", "a") as out:
                out.write(line)

    print(f"{100:6.2f} % |{progress(100)}|")
    tf = time.time()
    print(f"Analysis time: {tf-t0:.2f} s")


def load_data(file, t="LNVT"):
    """
    Load data from Stamp.dat.

    Parameters:
    -----------
    file : str
        Output file from STAMP.

    t : str
        Simulation type: LNVT or NPT.

    """
    names = {
        "LNVT": [
            "time",
            "Etot", "Epot", "Epot_intra", "Epot_inter", "Ekin",
            "T", "Tx", "Ty", "Tz",
            "P", "Px", "Py", "Pz",
            "Vx", "Vy", "Vz",
            "D", "cpu"],
        "NPT": [
            "time",
            "Etot", "Epot", "Epot_intra", "Epot_inter", "Ekin",
            "T", "Tx", "Ty", "Tz",
            "P", "Px", "Py", "Pz",
            "Cmvx", "Cmvy", "Cmvz",
            "Lx", "Ly", "Lz",
            "Vx", "Vy", "Vz",
            "Dens",
            "D", "cpu"
        ]}
    data = pd.read_csv(
        file,
        sep=r"\s+",
        header=None,
        names=names[t],
        comment="#"
                      )
    data["Etot"] = data["Etot"] * N_A / 1000  # to kJ/mol
    data["time"] = data["time"] * 1e12  # to ps
    data["P"] = data["P"] * 1e-5  # to bar

    return data


def load_log(file="Stamp.log"):
    """
    Load info from file log Stamp.

    Parameters:
    -----------
    file : str
        Output file from STAMP.

    """
    print("Reading log file", end=" - ")
    t0 = time.time()
    out_g = []
    out_frame = []
    with open(file, "r") as LOG:
        for line in LOG:
            if out_mean.match(line):
                m = out_mean.match(line)
                out_g.append(m.groupdict())

            if out_xyz.match(line):
                m = out_xyz.match(line)
                out_frame.append(m.groupdict())

    out_g = pd.DataFrame(out_g)
    out_g.drop_duplicates(inplace=True, ignore_index=True)
    out_g.set_index("frame", inplace=True)

    frame_dict = out_g["time"].to_dict()

    out_frame = pd.DataFrame(out_frame)
    out_frame.drop_duplicates(inplace=True, ignore_index=True)

    time_f = []
    for t in out_frame["frame"]:
        try:
            time_f.append(frame_dict[t])
        except KeyError:
            time_f.append(np.NaN)

    # out_frame["time"] = out_g.loc[out_frame["frame"].values, "time"].unique()
    out_frame["time"] = time_f
    out_frame.dropna(inplace=True)
    out_frame = out_frame.astype(
        {"frame": np.int64, "time": np.float64}
    )
    out_frame["time"] = out_frame["time"] * 1e12  # to ps

    print(f"done in {time.time()-t0:.2f} s")
    return out_frame


def save_system(obj, file="system.chk"):
    """Save the status of an object stamp."""
    with open(file, "wb") as CHK:
        pickle.dump(obj, CHK)

    print("Saved system status.")


def load_system(file):
    """Load the status of an objecto stamp."""
    with open(file, "rb") as CHK:
        system = pickle.load(CHK)

    return system


def save_plot(x, y, name, color="b", xlb="", ylb=""):
    """Save plots."""
    fig, ax = plt.subplots()

    ax.plot(x, y, color=color, alpha=0.8)
    # ax.hist(y, bins=100, orientation='horizontal', alpha=0.4, color=color)

    ax.set_xlabel(xlb)
    ax.set_ylabel(ylb)

    ax.set_title("Mean {:.3f} - std {:.3f}".format(y.mean(), y.std()))

    plt.savefig(f"{name}.png", dpi=300)
    plt.close()


def get_density(XYSs):
    """Return density of system using xyz stamp files."""
    pass


def traj_center_mass(traj, ndx_mol, top, box, connectivity, b=0, reset=True):
    """Return the center of mass of each molecule over time."""
    print("Center of mass analysis")
    t0 = time.time()

    # Number of frames read
    Nframes = len(traj)
    print(f"Number of frames: {Nframes}")

    if reset:
        out = open("molprop.csv", "w")
        out.write("frame,idx,Natoms,x,y,z\n")
        out.close()

    for n_frame, frame in enumerate(traj):
        porcent = n_frame * 100 / Nframes
        print(f"{porcent:6.2f} % |{progress(porcent)}|")
        if n_frame < b:
            continue
        for mol in ndx_mol:
            masses = top.loc[ndx_mol[mol]["index"], "mass"].values
            dfcoord = frame.loc[ndx_mol[mol]["index"], :]

            # Connectivity in the molecule
            connect = connectivity.sub_connect(ndx_mol[mol]["index"])

            # update coordinates
            connect.update_coordinates(dfcoord)

            # remove PBC
            connect.noPBC(box, center=np.zeros(3))

            # extract new coordinates
            newdfcoord = connect.get_df()
            coord = newdfcoord.loc[:, ["x", "y", "z"]].values

            mol_cm = center_of_mass(coord, masses)

            line = ""
            line += f"{n_frame},"
            line += f"{mol},"
            line += "{},".format(int(ndx_mol[mol]["Natoms"]))
            line += f"{mol_cm[0]:.3f},"
            line += f"{mol_cm[1]:.3f},"
            line += f"{mol_cm[2]:.3f}"
            line += "\n"
            # print(line)

            with open("molprop.csv", "a") as out:
                out.write(line)
            
    print(f"{100:6.2f} % |{progress(100)}|")
    tf = time.time()
    print(f"Analysis time: {tf-t0:.2f} s")


def minImagenC(q1, q2, L):
    dq = q2 - q1
    if dq > L * 0.5:
        dq -= L
    
    if dq <= -L * 0.5:
        dq += L
    
    return dq


def get_distances_from(mref, box, file="molprop.csv"):
    # file cm trajectory
    traj_mol_cm = pd.read_csv(file)
    # print(traj_mol_cm.isnull().values.any())
    # exit()
    traj_mol_cm["frame"] = traj_mol_cm["frame"].astype(np.int64)
    traj_mol_cm["idx"] = traj_mol_cm["idx"].astype(np.int64)

    # cm trajectory from ref
    traj_mref = traj_mol_cm[traj_mol_cm["idx"] == 0]

    # cm trajectory from others
    traj_not_mref = traj_mol_cm[traj_mol_cm["idx"] != 0]

    out = open(f"mol_dist_from_{mref}.csv", "w")
    out.write("frame,idx,distance\n")
    out.close()

    for frame in traj_mref["frame"]:
        print("frame", frame)
        mref_xyz = traj_mref[traj_mref["frame"] == frame].loc[:, ["x", "y", "z"]].values[0]
        # print(mref_xyz)
        not_mref_xyz = traj_not_mref[traj_not_mref["frame"] == frame].loc[:, ["idx", "x", "y", "z"]].values
        for mol in not_mref_xyz:
            pol_id = int(mol[0])
            #  print("Polimer id", pol_id)
            mol = mol[1:]
            dist = []
            for i in range(3):
                ndist = minImagenC(mref_xyz[i], mol[i], box[i])
                # ndist = mol[i] - mref_xyz[i]
                dist.append(ndist)
            dist = np.linalg.norm(dist)
            #print("distance", dist)
            line = ""
            line += f"{frame},"
            line += f"{pol_id},"
            line += f"{dist:.3f}"
            line += "\n"
            
            with open(f"mol_dist_from_{mref}.csv", "a") as out:
                out.write(line)


def get_angles_distance(mref, atref, box, traj, file="mol_cmass", b=0):

    def vecPBC(r1, r2, L):
        nr2 = np.zeros(3)
        for i in range(3):
            nr2[i] = minImagenC(r1[i], r2[i], L[i]) + r1[i]

        return nr2

    def VecNormal(atoms):
        # at1 is the reference atom
        at1 = atoms[0, :]
        at2 = atoms[1, :]
        at3 = atoms[2, :]

        #######
        # center
        nat2 = vecPBC(at1, at2, box)
        nat3 = vecPBC(at1, at3, box)

        #######
        # at1 --> natn
        #
        #            nat2
        #           /
        # at1      /
        #    \nat3/
        #
        v12 = nat2 - at1
        v13 = nat3 - at1

        return np.cross(v13, v12)

    # file cm trajectory
    traj_mol_cm = pd.read_csv(file)
    if b != 0:
        traj_mol_cm = traj_mol_cm[traj_mol_cm["frame"] >= b].copy()

    # cm trajectory from ref
    traj_mref = traj_mol_cm[traj_mol_cm["idx"] == mref]

    # cm trajectory from others
    traj_not_mref = traj_mol_cm[traj_mol_cm["idx"] != mref]

    out = open(f"mol_angles_d_{mref}.csv", "w")
    out.write("frame,idx,distance,cos,angles\n")
    out.close()
    iframe = 0

    for frame in traj_mref["frame"]:
        print("frame", frame)
        coord = traj[iframe]
        # print(coord)
        cm_ref = traj_mref[traj_mref["frame"] == frame].loc[:, ["x", "y", "z"]].values[0]
        # print("center of mass mol ref", cm_ref)

        atxyz = coord.loc[atref, ["x", "y", "z"]].values

        vnorm = VecNormal(atxyz)
        # print("Vector normal", vnorm)
        # c_vnorm = vnorm + cm_ref

        not_mref_xyz = traj_not_mref[traj_not_mref["frame"] == frame].loc[:, ["idx", "x", "y", "z"]].values
        for mol in not_mref_xyz:
            mol_id = int(mol[0])
            # print("molecule id", mol_id)

            mol_xyz = mol[1:]

            new_mol_xyz = vecPBC(cm_ref, mol_xyz, box)

            cm_ref_new_mol_xyz = new_mol_xyz - cm_ref

            distance_cm_mol = np.linalg.norm(cm_ref_new_mol_xyz)

            cos_th = np.dot(cm_ref_new_mol_xyz, vnorm) / np.linalg.norm(cm_ref_new_mol_xyz) / np.linalg.norm(vnorm)

            theta = np.arccos(cos_th) * 180.0 / np.pi

            line = ""
            line += f"{frame},"
            line += f"{mol_id},"
            line += f"{distance_cm_mol:.3f},"
            line += f"{cos_th:.2f},"
            line += f"{theta:.2f}"
            line += "\n"

            with open(f"mol_angles_d_{mref}.csv", "a") as out:
                out.write(line)

        iframe += 1


def translate_to(coord, center, box):
    """Translate coordinates using a reference center."""
    newcoord = np.zeros(coord.shape)
    for i, atom in enumerate(coord):
        for j, q in enumerate(atom):
            newcoord[i, j] = minImagenC(center[j], q, box[j])
    
    return newcoord


def change_atsb(x):
    """Change the FAtomes atom types to atoms from XYZ files."""
    if x in ["ca", "cb", "CT", "CM"]:
        return "C"
    elif x in ["ha", "ho", "HT", "HM"]:
        return "H"
    elif x in ["nf", "ne"]:
        return "N"
    elif x in ["oh"]:
        return "O"


def gen_centered_traj(traj, atoms_per_mol, connectivity, box, mol_dist, c_mass, rcutoff=1.5, ref=0, out_folder="centered_traj"):
    """Generate a trajectory of the system using a reference center."""
    traj_resid_in_r = mol_dist[mol_dist["distance"] <= rcutoff]
    traj_center_ref = c_mass[c_mass["idx"] == ref].loc[:, ["x", "y", "z"]].values

    # Output folder
    try:
        os.mkdir(out_folder)
    except FileExistsError:
        print("The output foler was already created")
        
    for frame, coord in enumerate(traj):
        name = "centered_mol_%04d" % frame
        
        resid = [ref] + list(traj_resid_in_r["idx"][traj_resid_in_r["frame"] == frame].values)
        center = traj_center_ref[frame]
        
        # atoms_ndx = []
        ncoords = []
        for res in resid:
            atoms = atoms_per_mol[res]["index"]
            mol_conn = connectivity.sub_connect(atoms)
            df = coord.loc[atoms, :]
            # Translate to a center of reference
            df.loc[:, ["x", "y", "z"]] = translate_to(df.loc[:, ["x", "y", "z"]].values, center, box)
            # update coordinates
            mol_conn.update_coordinates(df)
            # remove PBC
            mol_conn.noPBC(box, center=np.zeros(3))
            # Reset index and symbols, and add mass
            mol_conn = mol_conn.reset_nodes()
            mol_conn.simple_at_symbols()

            # Search and add hydrogen to vacant atoms
            mol_conn.add_hydrogen(box, type_add="terminal")
            new_mol_xyz = mol_conn.get_df()
            ncoords.append(new_mol_xyz)
            # ndf = mol_conn.get_df()
            # connects.update_coordinates(ndf)
            # atoms_ndx += atoms
        ####
        # sys_conn = connects.sub_connect(atoms_ndx)
        # new df
        # ndf = sys_conn.get_df()
        # ndf["atsb"] = ndf["atsb"].apply(change_atsb).values.astype(str)
        ncoords = pd.concat(ncoords, ignore_index=True)
        
        save_xyz(ncoords, name=f"{out_folder}/{name}")


def mol_traj_analysis(index, mol_ndx, connectivity, traj, box):
    """Analyze trajectory of a particular molecule."""
    i = 0
    for xyz in traj:
        name = "mol_%d_%005d" % (index, i)

        mol_xyz = xyz.loc[mol_ndx["index"], :]
        mol_conn = connectivity.sub_connect(mol_ndx["index"])
        # update coordinates
        mol_conn.update_coordinates(mol_xyz)

        # remove PBC
        mol_conn.noPBC(box, center=np.zeros(3))

        # Reset index and symbols, and add mass
        mol_conn = mol_conn.reset_nodes()
        mol_conn.simple_at_symbols(add_mass=True)

        # Search and add hydrogen to vacant atoms
        mol_conn.add_hydrogen(box, type_add="terminal")
        new_mol_xyz = mol_conn.get_df()

        cm = center_of_mass(
            new_mol_xyz.loc[:, ["x", "y", "z"]].values,
            new_mol_xyz.loc[:, "mass"].values
        )

        new_mol_xyz["x"] -= cm[0]
        new_mol_xyz["y"] -= cm[1]
        new_mol_xyz["z"] -= cm[2]

        save_xyz(new_mol_xyz, name=name)
        i += 1

    os.system(f"cat mol_{index}_0* > mol_{index}_traj.xyz")
    os.system(f"rm mol_{index}_0*")
    print(f"Saved trajectory mol {index} in mol_{index}_traj.xyz")


def PBC_distance(vref, v2, box):
    """Distance between two coordinates in periodic boundary conditions."""
    dist = []
    for i in range(len(box)):
        ndist = minImagenC(vref[i], v2[i], box[i])
        dist.append(ndist)
    
    return np.linalg.norm(np.array(dist))


def mol_traj_cut_distance(traj, atoms_per_mol, top, box, connectivity, ref, rcutoff=0.5, out_folder="mol_distances"):
    #(index, mol_dist, connectivity, traj, box, rcutoff=1.5,
    #ref=0, out_folder="centered_traj"):
    """Extract the structure of mol around a reference mol using atom-atom distance."""
    print(f"Extract the structure of molecules around a reference mol, resid {ref},")
    print(f"using atom-atom from a distance cut: {rcutoff:.2f} nm.")

    out_folder = out_folder + f"_{rcutoff}"
    rcutoff *= 10.
    masses = top.loc[atoms_per_mol[ref]["index"], "mass"].values

    # Output folder
    try:
        os.mkdir(out_folder)
    except FileExistsError:
        print("The output foler was already created")

    for frame, coord in enumerate(traj):
        name = "mol_around_%04d" % frame
        atoms_ref = atoms_per_mol[ref]["index"]
        mol_conn = connectivity.sub_connect(atoms_ref)
        mol_ref = coord.loc[atoms_ref, :]
        mol_xyz = mol_ref.loc[:, ["x", "y", "z"]].values

        mols_around = []
        for j in atoms_per_mol:
            if j != ref:
                # print(j)
                atoms_near = atoms_per_mol[j]["index"]
                # mol_conn_near = connectivity.sub_connect(atoms_near)
                mol_ref_near = coord.loc[atoms_near, :]
                mol_xyz_near = mol_ref_near.loc[:, ["x", "y", "z"]].values
                # print(mol_xyz_near)
                ##### DISTANCE Search
                for v_ref in mol_xyz:
                    new_mol = False
                    for v_near in mol_xyz_near:
                        r = PBC_distance(v_ref, v_near, box)
                        if r <= rcutoff:
                            mols_around.append(j)
                            new_mol = True
                            break
                    if new_mol:
                        break
                #####

        # update coordinates
        mol_conn.update_coordinates(mol_ref)
        # remove PBC
        mol_conn.noPBC(box, center=np.zeros(3))
        mol_coord = mol_conn.get_df()
        co = mol_coord.loc[:, ["x", "y", "z"]].values
        center = center_of_mass(co, masses)
        resids = [ref] + mols_around
        ncoords = []
        for res in resids:
            atoms = atoms_per_mol[res]["index"]
            mol_conn = connectivity.sub_connect(atoms)
            df = coord.loc[atoms, :]
            # Translate to a center of reference
            df.loc[:, ["x", "y", "z"]] = translate_to(df.loc[:, ["x", "y", "z"]].values, center, box)
            # update coordinates
            mol_conn.update_coordinates(df)
            # remove PBC
            mol_conn.noPBC(box, center=np.zeros(3))
            # Reset index and symbols, and add mass
            mol_conn = mol_conn.reset_nodes()
            mol_conn.simple_at_symbols()

            # Search and add hydrogen to vacant atoms
            mol_conn.add_hydrogen(box, type_add="terminal")
            new_mol_xyz = mol_conn.get_df()
            ncoords.append(new_mol_xyz)
            
        ncoords = pd.concat(ncoords, ignore_index=True)
        save_xyz(ncoords, name=f"{out_folder}/{name}")


def rdf_from_dist(df, box, rmin=0.0, rmax=6.0, binwidth=0.002):
    """Return rdf data and binned function."""
    def binned_distance(x):
        bins = np.arange(rmin, rmax, binwidth)
        index = np.digitize(x, bins)
        try:
            return bins[index]
        except IndexError:
            return np.NaN
        
    df["bin"] = df["distance"].apply(binned_distance)

    frames = df["frame"].unique()
    n_frames = len(frames)
    n_mol = df["distance"].count() / n_frames

    # Box in nanometers
    vol_per_com = box[0] * box[1] * box[2] / n_mol
    
    rdf = df.groupby("bin").count()
    rdf.reset_index(inplace=True)
    
    rdf["vshell"] = 4 * np.pi * ((binwidth + rdf["bin"])**3 - rdf["bin"]**3) / 3
    
    rdf["gr"] = rdf["distance"] * vol_per_com / rdf["vshell"] / n_frames
    rdf["weihts"] = vol_per_com / rdf["vshell"] / n_frames
    
    return rdf, binned_distance


def get_frame_distances_cm(traj, ref, near, cmass, box, rcutoff):
    """Distances per frame from center of mass references."""
    frame_distances = {}
    neighbor_list = set()
    nstlist = 1

    for frame, coord in enumerate(traj):

        # # ==== NEIGHBOR SEARCHING ====
        # # Update the neighbor list every nstlist iterations
        # if frame % nstlist == 0:
        #     neighbor_list = set()
        #     neighbor = []
        #     for j in near:
        #         mol_i = coord.loc[ref, ["x", "y", "z"]].values
        #         mol_j = coord.loc[j, ["x", "y", "z"]].values
        #         if PBC_distance(mol_i, mol_j, box) <= rcutoff * 10.0:
        #             neighbor.append(j)

        #      neighbor_list.update(neighbor.copy())

        ncoord = cmass[cmass["frame"] == frame].reset_index()
        mol_ref_xyz = ncoord.loc[[ref], ["x", "y", "z"]].values
        mol_near_xyz = ncoord.loc[near, ["x", "y", "z"]].values

        frame_distances[frame] = cdist(
            mol_ref_xyz, mol_near_xyz, lambda a, b: PBC_distance(a, b, box)
        )

    return frame_distances


def get_frame_distances(traj, atoms_ref, atoms_near, box, rcutoff):
    """Distances per frame from atoms references."""
    frame_distances = {}
    neighbor_list = set()
    nstlist = 50

    for frame, coord in enumerate(traj):
        # ==== NEIGHBOR SEARCHING ====
        # Update the neighbor list every nstlist iterations
        if frame % nstlist == 0:
            neighbor_list = set()
            for i in atoms_ref:
                neighbor = []
                for j in atoms_near:
                    if i == j:
                        continue
                    at_i = coord.loc[i, ["x", "y", "z"]].values
                    at_j = coord.loc[j, ["x", "y", "z"]].values

                    if PBC_distance(at_i, at_j, box) <= rcutoff * 10.0:
                        neighbor.append(j)

                neighbor_list.update(neighbor.copy())
        
        mol_ref = coord.loc[atoms_ref, :]
        mol_xyz = mol_ref.loc[:, ["x", "y", "z"]].values

        mol_near = coord.loc[list(neighbor_list), :]
        mol_xyz_near = mol_near.loc[:, ["x", "y", "z"]].values

        frame_distances[frame] = cdist(
            mol_xyz, mol_xyz_near, lambda a, b: PBC_distance(a, b, box)
        )

    return frame_distances


@decoTime
def rdf_analysis(ref, atoms, traj, atoms_per_mol, connectivity, top, box, vol, rmin=0.0, rmax=3.0, binwidth=0.05, name="rdf"):
    """Calculate the RDF of a molecule and its environment."""
    print("RDF analysis:", atoms, end=" - ")
    ########################################
    # TRY to chage
    # read molecules center of mass
    #molp = pd.read_csv("molprop.csv")
    ########################################

    # RDF type
    if atoms == "all":
        atoms_ref = atoms_per_mol[ref]["index"]
        atoms_near = []
        for i in atoms_per_mol:
            if i != ref:
                atoms_near += atoms_per_mol[i]["index"]
        name += "_all"
    elif atoms == "cm":
        atoms_ref = "cm"
        name += "_cm"
        molp = pd.read_csv("molprop.csv")
        atoms_near = []
        for i in atoms_per_mol:
            if i != ref:
                atoms_near.append(i)
    else:
        atoms_ref = [int(a) for a in atoms.split("-")]
        name += "_" + "-".join(list(top.loc[atoms_ref, "atsb"].values))

    # Define the bins
    bins = np.arange(rmin, rmax + binwidth, binwidth)

    # Obtains the distances per frames
    if atoms == "cm":
        frame_distances = get_frame_distances_cm(traj, ref, atoms_near, molp, box, rcutoff=rmax)
    else:
        frame_distances = get_frame_distances(traj, atoms_ref, atoms_near, box, rcutoff=rmax)

    if atoms_ref == "cm":
        n_centers = 1
    else:
        n_centers = len(atoms_ref)

    total_centers = n_centers + len(atoms_near)
    # print(total_centers)

    # total_n_centers = len(atoms_per_mol) - 1 + n_centers
    # vol_per_sphere = vol.mean() / total_n_centers
    ###vol_per_sphere = vol.mean() / (len(atoms_per_mol) - 1)
    ###vshell = 4 * np.pi * ((binwidth + bins)**3 - bins**3) / 3

    vol_per_sphere = vol.mean() / (total_centers - n_centers)
    vshell = 4 * np.pi * ((binwidth + bins)**3 - bins**3) / 3

    # rdf
    g_r = np.zeros(len(bins))
    for frame in frame_distances:
        for i, atom in enumerate(frame_distances[frame]):
            indexs = np.int64(atom * 0.1 / binwidth)
            indexs = indexs[indexs < len(bins)]
            for n in indexs:
                g_r[n] += 1

    n_frames = len(frame_distances.keys())
    g_r_norm = g_r * vol_per_sphere / vshell / n_frames / n_centers

    # return g_r_norm, bins
    RDF = pd.DataFrame({
        "g_r": g_r_norm,
        "r": bins
    })

    file = f"{name}.csv"
    RDF.to_csv(file, float_format="%.6f", index=None)
    print(f"file {file} saved.", end=" - ")


""" PLOTS FUNCTIONS """


confIsomer = {
        "cis": {"color": "#699deb", "lim": [-40, 40]},
        "trans": {"color": "#734f96", "lim": [-190, 190]}
    }


def thermo_plots(data):
    """Thermodynamic Analysis."""
    fig, axs = plt.subplots(ncols=3, figsize=(12,4))
    (ax1, ax2, ax3) = axs

    sns.lineplot(data=data, x="I", y="T", color="red", ax=ax1, alpha=0.8)
    ax1.set_ylabel("Temperature (K)")
    ax1.set_xlabel("time (ps)")
    ax1.set_title(
        r"$\bar T =$ {:.2f} $\pm$ {:.2f} K".format(
            data["T"].mean(),
            data["T"].std())
        )

    sns.lineplot(data=data, x="I", y="P", color="purple", ax=ax2, alpha=0.8)
    ax2.set_ylabel("Pressure (bar)")
    ax2.set_xlabel("time (ps)")
    ax2.set_title(
        r"$\bar P =$ {:.2f} $\pm$ {:.2f} bar".format(
            data["P"].mean(),
            data["P"].std())
        )

    sns.lineplot(data=data, x="I", y="Etot", color="green", ax=ax3, alpha=0.8)
    ax3.set_ylabel("Total Energy (kJ/mol)")
    ax3.set_xlabel("time (ps)")
    ax3.set_title(
        r"$\bar Etot =$ {:.2f} $\pm$ {:.2f} kJ/mol".format(
            data["Etot"].mean(),
            data["Etot"].std())
        )

    return fig, axs


def dih_plots(data, isomer):
    """Dihedrals Analysis."""
    fig, axs = plt.subplots(ncols=3, figsize=(12, 4))

    (ax1, ax2, ax3) = axs
    ylim = confIsomer[isomer]["lim"]

    sns.regplot(
        data=data,
        x="t", 
        y="torsion",
        ax=ax1,
        label=isomer,
        scatter_kws={"alpha": 0.6},
        line_kws={"color": "k"},
        color=confIsomer[isomer]["color"]
    )
    ax1.set_title("per time")
    ax1.set_ylabel("angle (degree)")
    ax1.set_xlabel("time (ps)")
    ax1.set_ylim(ylim)
    ax1.legend()

    sns.histplot(
        data=data,
        y="torsion",
        ax=ax2,
        label=isomer,
        binwidth=2,
        color=confIsomer[isomer]["color"]
    )
    ax2.set_title("histogram")
    ax2.set_ylabel("angle (degree)")
    ax2.set_xlabel("count")
    ax2.set_ylim(ylim)
    ax2.legend()

    sns.histplot(
        data=data,
        y="abs",
        ax=ax3,
        label=isomer,
        binwidth=2,
        color=confIsomer[isomer]["color"]
    )
    ax3.set_title("histogram (module)")
    ax3.set_ylabel("angle (degree)")
    ax3.set_xlabel("count")
    ax3.legend()

    box = {
        "facecolor": "0.85",
        "edgecolor": "k",
        "boxstyle": "round"
    }

    ax2.text(0.5, 0.2, r"{} - dih $=$ {:.2f} $\pm$ {:.2f} degre".format(
        isomer, data["torsion"].mean(),
        data["torsion"].std()
        ),
        transform=ax2.transAxes,
        bbox=box,
        ha="center")

    ax3.text(0.5, 0.2, r"{} - dih $=$ {:.2f} $\pm$ {:.2f} degre".format(
        isomer, data["abs"].mean(),
        data["abs"].std()
        ),
        transform=ax3.transAxes,
        bbox=box,
        ha="center")

    return fig, axs


def poly_plots_general(data):
    """Polymers analysis."""
    fig, axs = plt.subplots(ncols=3, figsize=(12, 4))

    sns.histplot(
        data=data,
        x="Rg",
        ax=axs[0],
        kde=True,
        color="#2a90a6",
        binwidth=0.5,
        stat="count",
        weights=1/data["frame"].max(),
        alpha=0.5
    )
    axs[0].set_xlabel("Radius of gyration ($\AA$)")
    axs[0].set_xlim(7, 25)

    sns.histplot(
        data=data,
        x="dmax",
        ax=axs[1],
        kde=True,
        color="#5b557b",
        binwidth=2.,
        stat="count",
        weights=1/data["frame"].max(),
        alpha=0.5
    )
    axs[1].set_xlabel("Max. distance ($\AA$)")
    axs[1].set_xlim(20, 90)

    sns.histplot(
        data=data,
        x="k2",
        ax=axs[2],
        kde=True,
        color="#fea6ad",
        binwidth=0.05,
        stat="count",
        weights=1/data["frame"].max()
    )
    axs[2].set_xlabel("Shape anisotropy")
    axs[2].set_xlim(0, 1)

    return fig, axs


def poly_plots_temporal(data):
    """Analysis of polymers in the time."""
    label = list(data["time"].unique())

    fig, axs = plt.subplots(nrows=len(label), ncols=3, figsize=(12, 2*len(label)))
    fig.subplots_adjust(hspace=0.1, wspace=0.2)

    box = {
        "facecolor": "0.85",
        "edgecolor": "k",
        "boxstyle": "round"
    }

    Analysis = {
        "Rg": {"color": "#2a90a6", "binw": 0.5, "xlim": [7, 22], "title": "Radius of gyration ($\AA$)"},
        "dmax": {"color": "#5b557b", "binw": 2.0, "xlim": [20, 80], "title": "Max. distance ($\AA$)"},
        "k2": {"color": "#fea6ad", "binw": 0.05, "xlim": [0, 1], "title": "Shape anisotropy"}
    }

    for i, t in enumerate(label):
        subdata = data[data["time"] == t]
        for j, anl in enumerate(Analysis):
            sns.histplot(
                data=subdata,
                x=anl,
                ax=axs[i, j],
                kde=True,
                color=Analysis[anl]["color"],
                binwidth=Analysis[anl]["binw"],
                stat="density",
                alpha=0.5
            )
            axs[i, j].set_xlim(Analysis[anl]["xlim"])
            axs[i, j].set_xlabel(Analysis[anl]["title"])
            axs[i, j].axvline(x=subdata[anl].mean(), color="k", ls="--", lw=2)

            if i != len(label)-1:
                axs[i, j].get_xaxis().set_visible(False)

        axs[i, 0].text(
            0.8, 0.8,
            "{}".format(t),
            transform=axs[i, 0].transAxes,
            bbox=box,
            ha="center"
        )

    return fig, axs


def dist_plots_general(data_prop):
    """Distances analysis."""
    fig, axs = plt.subplots(ncols=3, figsize=(12, 4))
    (ax1, ax2, ax3) = axs

    sns.histplot(
        data=data_prop,
        x="distance",
        binwidth=.1,
        kde=True,
        color="#9c89e8",
        stat="density",
        ax=ax1,
        cbar_kws={"alpha": 0.5}
    )
    ax1.axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax1.axvline(x=2.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax1.axvline(x=3.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax1.set_xlabel("distance (nm)")
    ax1.set_xlim(0, 5)

    sns.histplot(
        data=data_prop,
        x="distance",
        y="Rg",
        binwidth=[0.1, 0.5],
        ax=ax2, color="#537f6b"
        )
    ax2.axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax2.axvline(x=2.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax2.axvline(x=3.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax2.axhline(y=data_prop["Rg"].mean(), ls="--", color="#537f6b", lw=2.0, alpha=1.0)
    ax2.set_xlabel("distance (nm)")
    ax2.set_ylabel("Radius of gyration ($\AA$)")
    ax2.set_xlim(0, 5)
    ax2.set_ylim(7, 25)

    sns.histplot(data=data_prop, x="distance", y="k2", binwidth=[0.1, 0.05], ax=ax3, color="#5d3954")
    ax3.axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax3.axvline(x=2.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax3.axvline(x=3.5, ls="--", color="k", lw=2.0, alpha=0.7)
    ax3.axhline(y=data_prop["k2"].mean(), ls="--", color="#5d3954", lw=2.0, alpha=1.0)
    ax3.set_xlabel("distance (nm)")
    ax3.set_ylabel("Shape anisotropy")
    ax3.set_xlim(0, 5)
    ax3.set_ylim(0, 1)

    return fig, axs


def dist_plots_temporal(data):
    """Distances analysis in time."""
    label = list(data["time"].unique())
    
    fig, axs = plt.subplots(nrows=len(label), ncols=3, figsize=(12, 2*len(label)))
    fig.subplots_adjust(hspace=0.1, wspace=0.2)
    
    box = {
        "facecolor": "0.85",
        "edgecolor": "k",
        "boxstyle": "round"
    }
    
    Analysis = {
        "Rg": {"color": "#2a90a6", "binw": 0.5, "xlim": [7, 22], "title": "Radius of gyration ($\AA$)"},
        "dmax": {"color": "#5b557b", "binw": 2.0, "xlim": [20, 80], "title": "Max. distance ($\AA$)"},
        "k2": {"color": "#fea6ad", "binw": 0.05, "xlim": [0, 1], "title": "Shape anisotropy"}
    }
    
    for i, t in enumerate(label):
        subdata = data[data["time"] == t]
        for j, anl in enumerate(Analysis):
            if j == 0:
                sns.histplot(
                    data=subdata,
                    x="distance",
                    binwidth=.1,
                    kde=True,
                    color="#9c89e8",
                    stat="density",
                    ax=axs[i, j],
                    cbar_kws={"alpha": 0.5}
                )
                axs[i, j].axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
                #ax1.axvline(x=2.5, ls="--", color="k", lw=2.0, alpha=0.7)
                #ax1.axvline(x=3.5, ls="--", color="k", lw=2.0, alpha=0.7)
                axs[i, j].set_xlabel("distance (nm)")
                axs[i, j].set_xlim(0, 5)
                
            elif j == 1:
                sns.histplot(
                    data=subdata,
                    x="distance",
                    y="Rg",
                    binwidth=[0.1, 0.5],
                    ax=axs[i, j],
                    color="#537f6b"
                )
                axs[i, j].axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
                axs[i, j].axhline(y=subdata["Rg"].mean(), ls="--", color="#537f6b", lw=2.0, alpha=1.0)
                axs[i, j].set_xlabel("distance (nm)")
                axs[i, j].set_ylabel("Rg ($\AA$)")
                axs[i, j].set_xlim(0, 5)
                axs[i, j].set_ylim(7, 25)
                
            elif j == 2:
                sns.histplot(
                    data=subdata,
                    x="distance",
                    y="k2",
                    binwidth=[0.1, 0.05],
                    ax=axs[i, j],
                    color="#5d3954"
                )
                axs[i, j].axvline(x=1.5, ls="--", color="k", lw=2.0, alpha=0.7)
                axs[i, j].axhline(y=subdata["k2"].mean(), ls="--", color="#5d3954", lw=2.0, alpha=1.0)
                axs[i, j].set_xlabel("distance (nm)")
                axs[i, j].set_ylabel("Shape anisotropy")
                axs[i, j].set_xlim(0, 5)
                axs[i, j].set_ylim(0, 1)

            if i != len(label)-1:
                axs[i, j].get_xaxis().set_visible(False)
                
        axs[i, 0].text(
            0.85, 0.8,
            "{}".format(t),
            transform=axs[i, 0].transAxes,
            bbox=box,
            ha="center"
        )
    
    return fig, axs


def rdf_plots_general(data_prop):
    """Distance analysis using rdf normalization."""
    fig, axs = plt.subplots(ncols=3, figsize=(12, 4))
    
    (ax1, ax2, ax3) = axs
    
    sns.lineplot(
        data=data_prop,
        x="distance",
        y="gr",
        ax=ax1,
        color="#9c89e8"
    )
    ax1.axhline(y=1.0, ls="--", color="gray")
    ax1.axvline(x=1.7, ls="--", color="black")
    ax1.set_xlabel("r (nm)")
    ax1.set_ylabel("g (r)")
    ax1.set_xlim(0, 3)
    
    sns.histplot(
        data=data_prop,
        x="distance",
        y="Rg",
        binwidth=[0.1, 0.5],
        weights="w",
        ax=ax2,
        color="#537f6b"
    )
    ax2.set_xlim(0, 3)
    ax2.set_ylim(7, 25)
    ax2.set_xlabel("r (nm)")
    ax2.set_ylabel("Radius of gyration ($\AA$)")
    
    ax2.axhline(y=data_prop["Rg"].mean(), ls="--", color="#537f6b", lw=2.0, alpha=1.0)
    ax2.axvline(x=1.7, ls="--", color="black")
    
    sns.histplot(
        data=data_prop,
        x="distance",
        y="k2",
        binwidth=[0.1, 0.05],
        weights="w",
        ax=ax3,
        color="#5d3954"
    )
    ax3.set_xlim(0, 3)
    ax3.set_ylim(0, 1)
    ax3.set_xlabel("r (nm)")
    ax3.set_ylabel("Shape anisotropy")
    ax3.axhline(y=data_prop["k2"].mean(), ls="--", color="#5d3954", lw=2.0, alpha=1.0)
    ax3.axvline(x=1.7, ls="--", color="black")

    return fig, axs


def rdf_plots_temporal(data, L):
    """Distances rdf analysis in time."""
    label = list(data["time"].unique())
    
    fig, axs = plt.subplots(nrows=len(label), ncols=3, figsize=(12, 2*len(label)))
    fig.subplots_adjust(hspace=0.1, wspace=0.2)
    
    box = {
        "facecolor": "0.85",
        "edgecolor": "k",
        "boxstyle": "round"
    }
    
    Analysis = {
        "Rg": {"color": "#2a90a6", "binw": 0.5, "xlim": [7, 22], "title": "Radius of gyration ($\AA$)"},
        "dmax": {"color": "#5b557b", "binw": 2.0, "xlim": [20, 80], "title": "Max. distance ($\AA$)"},
        "k2": {"color": "#fea6ad", "binw": 0.05, "xlim": [0, 1], "title": "Shape anisotropy"}
    }

    for i, t in enumerate(label):
        subdata = data[data["time"] == t].copy()
        rdf, binned_distance = rdf_from_dist(subdata.copy(), L * 0.1, rmax=3.1, binwidth=0.05)
        rdf.set_index("bin", inplace=True)
        subdata.loc[:, "distance"] = subdata["distance"].apply(binned_distance)
        subdata.dropna(axis=0, inplace=True)

        subdata.loc[:, "gr"] = subdata["distance"].apply(lambda x: rdf.loc[x, "gr"])
        subdata.loc[:, "w"] = subdata["distance"].apply(lambda x: rdf.loc[x, "weihts"])

        for j, anl in enumerate(Analysis):
            if j == 0:
                """RDF"""
                sns.lineplot(
                    data=subdata,
                    x="distance",
                    y="gr",
                    ax=axs[i, j],
                    color="#9c89e8"
                )
                axs[i, j].axhline(y=1.0, ls="--", color="gray")
                axs[i, j].axvline(x=1.7, ls="--", color="black")
                axs[i, j].set_xlabel("r (nm)")
                axs[i, j].set_ylabel("g (r)")
                axs[i, j].set_xlim(0, 3)

            elif j == 1:
                """Rg vs distance"""
                sns.histplot(
                    data=subdata,
                    x="distance",
                    y="Rg",
                    binwidth=[0.1, 0.5],
                    weights="w",
                    ax=axs[i, j],
                    color="#537f6b"
                )
                axs[i, j].set_xlim(0, 3)
                axs[i, j].set_ylim(7, 25)
                axs[i, j].set_xlabel("r (nm)")
                axs[i, j].set_ylabel("Radius of gyration ($\AA$)")
    
                axs[i, j].axhline(y=subdata["Rg"].mean(), ls="--", color="#537f6b", lw=2.0, alpha=1.0)
                axs[i, j].axvline(x=1.7, ls="--", color="black")

            elif j == 2:
                """shape anisotrope"""
                sns.histplot(
                    data=subdata,
                    x="distance",
                    y="k2",
                    binwidth=[0.1, 0.05],
                    weights="w",
                    ax=axs[i, j],
                    color="#5d3954"
                )
                axs[i, j].set_xlim(0, 3)
                axs[i, j].set_ylim(0, 1)
                axs[i, j].set_xlabel("r (nm)")
                axs[i, j].set_ylabel("Shape anisotropy")
                axs[i, j].axhline(y=subdata["k2"].mean(), ls="--", color="#5d3954", lw=2.0, alpha=1.0)
                axs[i, j].axvline(x=1.7, ls="--", color="black")

            if i != len(label)-1:
                axs[i, j].get_xaxis().set_visible(False)

        axs[i, 0].text(
            0.85, 0.8,
            "{}".format(t),
            transform=axs[i, 0].transAxes,
            bbox=box,
            ha="center"
        )

    return fig, axs


def plots_mean_per_time(data):
    """Means per time groups."""
    fig, axs = plt.subplots(ncols=3, figsize=(12, 4))

    box = {
        "facecolor": "0.85",
        "edgecolor": "k",
        "boxstyle": "round"
    }

    (ax1, ax2, ax3) = axs

    ax1.errorbar(
        data["t"], data["Rg"]["mean"],
        yerr=data["Rg"]["std"], fmt="o", capsize=4,
        color="black", ecolor="#2a90a6"
    )
    regress = linregress(data["t"], y=data["Rg"]["mean"])
    ax1.plot(data["t"], data["t"] * regress.slope + regress.intercept)
    ax1.set_ylim(7, 25)
    ax1.set_xlabel("time (ps)")
    ax1.set_ylabel("Radius of gyration ($\AA$)")

    ax1.text(
        0.5, 0.8,
        "{:.2f}x+{:.2f} - R2 = {:.3f}".format(regress.slope, regress.intercept, regress.rvalue**2),
        transform=ax1.transAxes,
        bbox=box,
        ha="center"
    )

    ax2.errorbar(
        data["t"], data["dmax"]["mean"],
        yerr=data["dmax"]["std"], fmt="o", capsize=4,
        color="black", ecolor="#5b557b"
    )
    regress = linregress(data["t"], y=data["dmax"]["mean"])
    ax2.plot(data["t"], data["t"] * regress.slope + regress.intercept)
    ax2.set_ylim(20, 90)
    ax2.set_xlabel("time (ps)")
    ax2.set_ylabel("Max. distance ($\AA$)")

    ax2.text(
        0.5, 0.8,
        "{:.2f}x+{:.2f} - R2 = {:.3f}".format(regress.slope, regress.intercept, regress.rvalue**2),
        transform=ax2.transAxes,
        bbox=box,
        ha="center"
    )

    ax3.errorbar(
        data["t"], data["k2"]["mean"],
        yerr=data["k2"]["std"], fmt="o", capsize=4,
        color="black", ecolor="#5b557b"
    )
    regress = linregress(data["t"], y=data["k2"]["mean"])
    ax3.plot(data["t"], data["t"] * regress.slope + regress.intercept)
    ax3.set_ylim(0, 1)
    ax3.set_xlabel("time (ps)")
    ax3.set_ylabel("Shape anisotropy")

    ax3.text(
        0.5, 0.8,
        "{:.2f}x+{:.2f} - R2 = {:.3f}".format(regress.slope, regress.intercept, regress.rvalue**2),
        transform=ax3.transAxes,
        bbox=box,
        ha="center"
    )

    return fig, axs


def plots_mean_per_dist(data):
    """Means per distance groups."""
    fig, axs = plt.subplots(nrows=1, ncols=3, figsize=(12, 4))

    cols = {
        "Rg": {"label": "Radius of gyration ($\AA$)"},
        "dmax": {"label": "Max. distance ($\AA$)"},
        "k2": {"label": "Shape anisotropy"}
    }

    for i, name in enumerate(cols):
        axs[i].errorbar(
            data["d"],
            y=data[name]["mean"],
            yerr=data[name]["std"],
            fmt="o",
            capsize=4,
            color="black",
            ecolor="#fd9283"
        )
        axs[i].set_ylabel(cols[name]["label"])
        axs[i].set_xlabel("distance (nm)")

    return fig, axs


def GenPlots(
    home, pc,  step, replica, isomer, name, out, t_min=500, t_max=2500,
    t_step=500, rmin=0, rmax=3.1, binwidth=0.5, thermo=True, dihedrals=True, polymer=True, distances=True,
    rdfs=True, means=True, not_plots=False, return_data=False
):
    """Graph and save all analyses."""
    sys = load_system(f"{home}/{pc}_procedure/{step}_prod_{replica}/system.chk")
    lims = np.arange(t_min, t_max + t_step, t_step)
    alldata = {}

    def binned_time(x):
        ind = np.digitize(x, lims)
        try:
            return f"{lims[ind]}ps"
        except IndexError:
            return np.NaN

    def binned_distance(x):
        bins = np.arange(rmin, rmax, binwidth)
        index = np.digitize(x, bins)
        try:
            return bins[index]
        except IndexError:
            return np.NaN

    """Termodynamics."""
    alldata["thermo"] = sys.data
    if thermo and not not_plots:
        fig, axs = thermo_plots(sys.data)
        fig.suptitle(
            f"Thermodynamic properties - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_thermo_s{step}r{replica}.png", dpi=300)

    """Dihedrals."""
    sys_dih = pd.read_csv(f"{home}/{pc}_procedure/{step}_prod_{replica}/dihedrals.dat", sep="\s+", header=None, index_col=0, names=["torsion"])
    sys_dih["t"] = sys.time_per_frame["time"]
    sys_dih["abs"] = sys_dih["torsion"].abs()
    alldata["dihedral"] = sys_dih
    if dihedrals and not not_plots:
        fig, axs = dih_plots(sys_dih, isomer)
        fig.suptitle(f"Torsion angles in polymer matrix - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_dihs_s{step}r{replica}.png", dpi=300)

    """Polymers."""
    sys_pol = pd.read_csv(f"{home}/{pc}_procedure/{step}_prod_{replica}/polymers.csv")
    # frame_to_time = dict(enumerate(sys.data["I"][::10].values[1:]))
    frame_to_time = {i: sys.time_per_frame.loc[i, "time"] for i in sys.time_per_frame.index}
    sys_pol["time"] = sys_pol["frame"].apply(lambda x: frame_to_time[x])
    pol_c = sys_pol[sys_pol["idx"] != 0].copy()
    pol_c["time"] = pol_c["time"].apply(binned_time)
    pol_t = pol_c.dropna(axis=0)
    alldata["pol_g"] = pol_c
    alldata["pol_t"] = pol_t

    if polymer and not not_plots:
        fig, axs = poly_plots_general(pol_c)
        fig.suptitle(f"Global analysis of the polymeric matrix - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_poly_g_s{step}r{replica}.png", dpi=300)

        """Polymer by time."""
        fig, axs = poly_plots_temporal(pol_t)
        fig.suptitle(f"Polymeric analysis by time period - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_poly_t_s{step}r{replica}.png", dpi=300)

    """Distances."""
    sys_dist = pd.read_csv(f"{home}/{pc}_procedure/{step}_prod_{replica}/mol_dist_from_0.csv")
    sys_dist["distance"] *= 0.1

    dprop = pd.DataFrame({
        "distance": sys_dist["distance"].values,
        "Rg": pol_c["Rg"].values,
        "k2": pol_c["k2"].values,
        "dmax": pol_c["dmax"].values,
        "time": pol_c["time"].values
    })

    dprop.dropna(axis=0, inplace=True)
    alldata["distance"] = dprop
    if distances and not not_plots:
        fig, axs = dist_plots_general(dprop)
        fig.suptitle(f"Global analysis of the distances from the PC - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_dist_g_s{step}r{replica}.png", dpi=300)

        # Distance by time
        fig, axs = dist_plots_temporal(dprop)
        fig.suptitle(f"Distances analysis by time period - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_dist_t_s{step}r{replica}.png", dpi=300)

    """ RDF distances general."""
    dprop = pd.DataFrame({
        "distance": sys_dist["distance"].values,
        "Rg": pol_c["Rg"].values,
        "k2": pol_c["k2"].values,
        "dmax": pol_c["dmax"].values,
        "time": pol_c["time"].values,
        "frame": pol_c["frame"].values
    })

    rdf, bindistance = rdf_from_dist(sys_dist, sys.box * 0.1, rmax=3.1, binwidth=0.05)
    rdf.set_index("bin", inplace=True)
    dprop["distance"] = dprop["distance"].apply(bindistance)
    dprop.dropna(axis=0, inplace=True)
    dprop["gr"] = dprop["distance"].apply(lambda x: rdf.loc[x, "gr"])
    dprop["w"] = dprop["distance"].apply(lambda x: rdf.loc[x, "weihts"])

    alldata["rdf"] = dprop

    if rdfs and not not_plots:
        fig, axs = rdf_plots_general(dprop)
        fig.suptitle(f"RDF analysis from the PC - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_rdf_g_s{step}r{replica}.png", dpi=300)

        # sys_dist["time"] = sys_dist["frame"].apply(lambda x: frame_to_time[x])
        # sys_dist["time"] = sys_dist["time"].apply(binned_time)
        # sys_dist.dropna(axis=0, inplace=True)

        fig, axs = rdf_plots_temporal(dprop, sys.box)
        fig.suptitle(f"RDF analysis of the distances by time period - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_rdf_t_s{step}r{replica}.png", dpi=300)

    aggregation = {
        "Rg": ["mean", "std"],
        "k2": ["mean", "std"],
        "dmax": ["mean", "std"]
    }

    dprop_resume = dprop.groupby("time").agg(aggregation)
    dprop_resume["t"] = [int(i.replace("ps", "")) for i in dprop_resume.index]

    alldata["resume_t"] = dprop_resume

    dfdist = alldata["distance"]
    dfdist["d"] = dfdist["distance"].apply(binned_distance)
    dfresume = dfdist.groupby("d").agg(aggregation)
    dfresume.reset_index(inplace=True)
    alldata["resume_d"] = dfresume

    if means and not not_plots:
        fig, axs = plots_mean_per_time(dprop_resume)
        fig.suptitle(f"Mean analysis of polymer per time - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_means_t_s{step}r{replica}.png", dpi=300)

        fig, axs = plots_mean_per_dist(dfresume)
        fig.suptitle(f"Mean analysis of polymer per distance - step {step} replica {replica} - AzoO {isomer}", fontweight="bold")
        plt.tight_layout()
        plt.savefig(f"{out}/{name}_means_d_s{step}r{replica}.png", dpi=300)

    if return_data:
        return alldata
