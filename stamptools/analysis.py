"""Module dedicated to the analysis of trajectories generated by STAMP."""

import re
import time
import numpy as np
import pandas as pd
from scipy.constants import N_A
import pickle
import matplotlib.pyplot as plt
import glob


""" Regular expression that extracts matrix XYZ """
atoms = re.compile(r"""
        ^\s+
        (?P<atsb>[A-Za-z]+\d?\d?)\s+      # Atom name.
        (?P<x>[+-]?\d+\.\d+)\s+           # Orthogonal coordinates for X.
        (?P<y>[+-]?\d+\.\d+)\s+           # Orthogonal coordinates for Y.
        (?P<z>[+-]?\d+\.\d+)\s+           # Orthogonal coordinates for Z.
        """, re.X)

noms = re.compile(r"""
    nom\s+(?P<nom>\w+)               # Atom name
    """, re.X)

masses = re.compile(r"""
    masse\s+(?P<mass>\d+\.\w+[+-]?\d+)               # Atom name
    """, re.X)


def read_fatomes(file):
    """Read Fatomes file."""
    natypes = 0
    atomsM = {}
    xyz = []
    lnom = []
    lmass = []
    connects = dict()
    with open(file, "r") as FATM:
        for line in FATM:

            if noms.match(line):
                m = noms.match(line)
                lnom.append(m.groupdict())

            if masses.match(line):
                m = masses.match(line)
                lmass.append(m.groupdict())

            if "*" == line[0]:
                # ignore lines with the * symbol
                continue

            elif "NbTypesAtomes" in line:
                line = line.split()
                natypes += int(line[1])
                continue

            elif "maille_long" in line:
                line = line.split()
                box = np.array(line[1:4]).astype(np.float64)
                continue

            elif "PositionDesAtomesCart" in line:
                Natoms = int(FATM.readline())
                continue

            elif atoms.match(line):
                m = atoms.match(line)
                xyz.append(m.groupdict())

            elif "Zmatrice" in line:
                N = int(FATM.readline())
                print("N conectivity:", N)
                for _ in range(N):
                    zline = FATM.readline()
                    zline = zline.split()
                    zline = [int(i) for i in zline]
                    connects[zline[0]] = zline[1:]

    atomsM = dict()
    print("Atoms names:", lnom, len(lnom))

    print("Atoms masses:", lmass, len(lmass))

    print(list(range(len(lnom))))

    if len(lmass) == len(lnom):
        # print("Esta bien, son iguales")
        for i in range(len(lnom)):
            atomsM[lnom[i]["nom"]] = np.float64(lmass[i]["mass"])
    else:
        print("ERROR, no; and masses dont similar")
        exit()

    print("Number of atoms in XYZ matrix:", Natoms)

    print("ATOMS types and Mass [Kg/mol]")
    print(atomsM)

    print("Box dimensions [angs]:")
    print(box)

    tabXYZ = pd.DataFrame(xyz)

    tabXYZ = tabXYZ.astype({
        "x": np.float64,
        "y": np.float64,
        "z": np.float64
    })

    try:
        tabXYZ["mass"] = tabXYZ["atsb"].apply(lambda x: atomsM[x])
    except KeyError:
        print(atomsM)
        print(tabXYZ.loc[0:26, :])
        print("ERROR")
        exit()

    return tabXYZ, box, connects


def progress(p):
    """Indicate on a bar the progress of the analysis."""
    bar = int(p * 40 / 100)
    return bar*"=" + (40-bar)*" "


def center_of_mass(coords, masses):
    """Compute the center of mass, the mass weighterd barycenter."""
    return np.sum(coords * masses[:, np.newaxis], axis=0) / masses.sum()


def traj_analysis(ndx_mol, top, traj, box, connectivity, GyrationTensor):
    """
    Analyze properties during a simulation.

    Parameters
    ----------
    ndx_mol : dict
        Dictionary with the indexes of each molecule to be analyzed.

    top : DataFrame
        File with the system topology.

    traj : list(DataFrame)
        Defines the trajectory of the system in a list of Dataframes.

    box : numpy.array (1x3)
        Vector box.

    connectivity : molcraft.structure.connectivity
        System connectivity.

    GyrationTensor : class
        Class that builds the information.


    """
    print("Polymer analysis")
    t0 = time.time()

    # Number of frames read
    Nframes = len(traj)
    print(f"Number of frames: {Nframes}")

    out = open("polymers.csv", "w")
    out.write(",frame,idx,Natoms,Rg,k2,dmax\n")
    out.close()

    index = 0

    for i, frame in enumerate(traj):
        porcent = i * 100 / Nframes
        print(f"{porcent:5.2f} % |{progress(porcent)}|")
        for mol in ndx_mol:
            masses = top.loc[ndx_mol[mol]["index"], "mass"].values
            dfcoord = frame.loc[ndx_mol[mol]["index"], :]

            # Connectivity in the molecule
            connect = connectivity.sub_connect(ndx_mol[mol]["index"])

            # update coordinates
            connect.update_coordinates(dfcoord)

            # remove PBC
            connect.noPBC(box)

            newdfcoord = connect.get_df()
            coord = newdfcoord.loc[:, ["x", "y", "z"]].values

            G = GyrationTensor(coord, masses, box, pbc=False)

            line = ""
            line += f"{index},"
            line += f"{i},"
            line += f"{mol},"
            line += "{},".format(int(ndx_mol[mol]["Natoms"]))
            line += f"{G.iso_w_rg:.2f},"
            line += f"{G.shape_anisotropy:.3f},"
            line += f"{G.max_distance:.2f}"
            line += "\n"
            # print(line)

            with open("polymers.csv", "a") as out:
                out.write(line)
            
            index += 1

    tf = time.time()
    print(f"Analysis time: {tf-t0:.2f} s")


def load_data(file, t="LNVT"):
    """
    Load data from Stamp.dat.

    Parameters:
    -----------
    file : str
        Output file from STAMP.

    t : str
        Simulation type: NVT or NPT.

    """
    names = {
        "LNVT": [
            "I",
            "Etot", "Epot", "Epot_intra", "Epot_inter", "Ekin",
            "T", "Tx", "Ty", "Tz",
            "P", "Px", "Py", "Pz",
            "Vx", "Vy", "Vz",
            "D", "cpu"],
        "NPT": [
            "I",
            "Etot", "Epot", "Epot_intra", "Epot_inter", "Ekin",
            "T", "Tx", "Ty", "Tz",
            "P", "Px", "Py", "Pz",
            "Cmvx", "Cmvy", "Cmvz",
            "Lx", "Ly", "Lz",
            "Vx", "Vy", "Vz",
            "Dens",
            "D", "cpu"
        ]}
    data = pd.read_csv(
        file,
        sep=r"\s+",
        header=None,
        names=names[t],
        comment="#"
                      )
    data["Etot"] = data["Etot"] * N_A / 1000  # to kJ/mol
    data["I"] = data["I"] * 1e12  # to ps
    data["P"] = data["P"] * 1e-5  # to bar

    return data


def save_system(obj, file="system.chk"):
    """Save the status of an object stamp."""
    with open(file, "wb") as CHK:
        pickle.dump(obj, CHK)

    print("Saved system status.")


def load_system(file):
    """Load the status of an objecto stamp."""
    with open(file, "rb") as CHK:
        system = pickle.load(CHK)

    return system


def save_plot(x, y, name, color="b", xlb="", ylb=""):
    """Save plots."""
    fig, ax = plt.subplots()

    ax.plot(x, y, color=color, alpha=0.8)
    # ax.hist(y, bins=100, orientation='horizontal', alpha=0.4, color=color)

    ax.set_xlabel(xlb)
    ax.set_ylabel(ylb)

    ax.set_title("Mean {:.3f} - std {:.3f}".format(y.mean(), y.std()))

    plt.savefig(f"{name}.png", dpi=300)
    plt.close()


def get_density(XYSs):
    """Return density of system using xyz stamp files."""
    pass


def traj_center_mass(traj, ndx_mol, top, box, connectivity):
    """Return the center of mass of each molecule over time."""
    print("Center of mass analysis")
    t0 = time.time()

    # Number of frames read
    Nframes = len(traj)
    print(f"Number of frames: {Nframes}")

    out = open("mol_cmass.csv", "w")
    out.write(",frame,idx,Natoms,x,y,z\n")
    out.close()

    tf = time.time()
    print(f"Analysis time: {tf-t0:.2f} s")

    index = 0
    for i, frame in enumerate(traj):
        porcent = i * 100 / Nframes
        print(f"{porcent:5.2f} % |{progress(porcent)}|")
        for mol in ndx_mol:
            masses = top.loc[ndx_mol[mol]["index"], "mass"].values
            dfcoord = frame.loc[ndx_mol[mol]["index"], :]

            # Connectivity in the molecule
            connect = connectivity.sub_connect(ndx_mol[mol]["index"])

            # update coordinates
            connect.update_coordinates(dfcoord)

            # remove PBC
            connect.noPBC(box)

            # extract new coordinates
            newdfcoord = connect.get_df()
            coord = newdfcoord.loc[:, ["x", "y", "z"]].values

            mol_cm = center_of_mass(coord, masses)

            line = ""
            line += f"{index},"
            line += f"{i},"
            line += f"{mol},"
            line += "{},".format(int(ndx_mol[mol]["Natoms"]))
            line += f"{mol_cm[0]:.3f},"
            line += f"{mol_cm[1]:.3f},"
            line += f"{mol_cm[2]:.3f}"
            line += "\n"
            # print(line)

            with open("mol_cmass.csv", "a") as out:
                out.write(line)
            
            index += 1


def minImagenC(q1, q2, L):
    dq = q2 - q1
    if dq > L * 0.5:
        dq -= L
    
    if dq <= -L * 0.5:
        dq += L
    
    return dq


def get_distances_from(mref, box, file="mol_cmass.csv"):
    # file cm trajectory
    traj_mol_cm = pd.read_csv(file, index_col=0, header=0)

    # cm trajectory from ref
    traj_mref = traj_mol_cm[traj_mol_cm["idx"] == 0]

    # cm trajectory from others
    traj_not_mref = traj_mol_cm[traj_mol_cm["idx"] != 0]

    out = open(f"mol_dist_from_{mref}.csv", "w")
    out.write("frame,idx,distance\n")
    out.close()
    
    for frame in traj_mref["frame"]:
        print("frame", frame)
        mref_xyz = traj_mref[traj_mref["frame"] == 0].loc[:, ["x", "y", "z"]].values[0]
        # print(mref_xyz)
        not_mref_xyz = traj_not_mref[traj_not_mref["frame"] == 0].loc[:, ["idx", "x", "y", "z"]].values
        for mol in not_mref_xyz:
            pol_id = int(mol[0])
            #  print("Polimer id", pol_id)
            mol = mol[1:]
            dist = []
            for i in range(3):
                ndist = minImagenC(mref_xyz[i], mol[i], box[i])
                # ndist = mol[i] - mref_xyz[i]
                dist.append(ndist)
            dist = np.linalg.norm(dist)
            #print("distance", dist)
            line = ""
            line += f"{frame},"
            line += f"{pol_id},"
            line += f"{dist:.3f}"
            line += "\n"
            
            with open(f"mol_dist_from_{mref}.csv", "a") as out:
                out.write(line)
